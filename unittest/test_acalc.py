#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Module:   test_acalc.py
# Purpose:  arrayfunc unit test.
# Language: Python 3.4
# Date:     12-Jan-2016.
# Ver:      01-Apr-2016.
#
###############################################################################
#
#   Copyright 2014 - 2016    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################
"""This conducts unit tests for acalc.
"""

##############################################################################
import array
import itertools
import math
import operator
import platform

import unittest

import arrayfunc

##############################################################################

##############################################################################

# The following code is all auto-generated.



##############################################################################
class acalcccomp_calc_init_b(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code b.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code b.
		"""
		self.assertEqual(self.eqn._DataType, 'int')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code b.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code b.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_h(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code h.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code h.
		"""
		self.assertEqual(self.eqn._DataType, 'int')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code h.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code h.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_i(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code i.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code i.
		"""
		self.assertEqual(self.eqn._DataType, 'int')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code i.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code i.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_l(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code l.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code l.
		"""
		self.assertEqual(self.eqn._DataType, 'int')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code l.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code l.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_q(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code q.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code q.
		"""
		self.assertEqual(self.eqn._DataType, 'int')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code q.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code q.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_B(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code B.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code B.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code B.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code B.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_H(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code H.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code H.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code H.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code H.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_I(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code I.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code I.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code I.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code I.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_L(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code L.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code L.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code L.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code L.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_Q(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code Q.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code Q.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code Q.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code Q.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_f(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code f.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code f.
		"""
		self.assertEqual(self.eqn._DataType, 'float')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code f.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code f.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_d(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code d.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code d.
		"""
		self.assertEqual(self.eqn._DataType, 'float')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code d.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code d.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_bytes(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code bytes.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code bytes.
		"""
		self.assertEqual(self.eqn._DataType, 'uint')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code bytes.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code bytes.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_init_mismatch(unittest.TestCase):
	"""Test for basic class initialisation array type mismatch.
	"""
	# Template: calc_init_mismatch_template




	########################################################
	def test_compile_init_mismatch_arraytypes_b_B(self):
		"""Test acalc compile init array types  - Input array code b, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_h(self):
		"""Test acalc compile init array types  - Input array code b, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_H(self):
		"""Test acalc compile init array types  - Input array code b, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_i(self):
		"""Test acalc compile init array types  - Input array code b, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_I(self):
		"""Test acalc compile init array types  - Input array code b, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_l(self):
		"""Test acalc compile init array types  - Input array code b, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_L(self):
		"""Test acalc compile init array types  - Input array code b, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_q(self):
		"""Test acalc compile init array types  - Input array code b, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_Q(self):
		"""Test acalc compile init array types  - Input array code b, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_f(self):
		"""Test acalc compile init array types  - Input array code b, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_d(self):
		"""Test acalc compile init array types  - Input array code b, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_b(self):
		"""Test acalc compile init array types  - Input array code B, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_h(self):
		"""Test acalc compile init array types  - Input array code B, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_H(self):
		"""Test acalc compile init array types  - Input array code B, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_i(self):
		"""Test acalc compile init array types  - Input array code B, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_I(self):
		"""Test acalc compile init array types  - Input array code B, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_l(self):
		"""Test acalc compile init array types  - Input array code B, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_L(self):
		"""Test acalc compile init array types  - Input array code B, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_q(self):
		"""Test acalc compile init array types  - Input array code B, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_Q(self):
		"""Test acalc compile init array types  - Input array code B, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_f(self):
		"""Test acalc compile init array types  - Input array code B, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_d(self):
		"""Test acalc compile init array types  - Input array code B, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_b(self):
		"""Test acalc compile init array types  - Input array code h, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_B(self):
		"""Test acalc compile init array types  - Input array code h, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_H(self):
		"""Test acalc compile init array types  - Input array code h, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_i(self):
		"""Test acalc compile init array types  - Input array code h, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_I(self):
		"""Test acalc compile init array types  - Input array code h, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_l(self):
		"""Test acalc compile init array types  - Input array code h, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_L(self):
		"""Test acalc compile init array types  - Input array code h, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_q(self):
		"""Test acalc compile init array types  - Input array code h, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_Q(self):
		"""Test acalc compile init array types  - Input array code h, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_f(self):
		"""Test acalc compile init array types  - Input array code h, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_d(self):
		"""Test acalc compile init array types  - Input array code h, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_b(self):
		"""Test acalc compile init array types  - Input array code H, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_B(self):
		"""Test acalc compile init array types  - Input array code H, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_h(self):
		"""Test acalc compile init array types  - Input array code H, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_i(self):
		"""Test acalc compile init array types  - Input array code H, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_I(self):
		"""Test acalc compile init array types  - Input array code H, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_l(self):
		"""Test acalc compile init array types  - Input array code H, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_L(self):
		"""Test acalc compile init array types  - Input array code H, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_q(self):
		"""Test acalc compile init array types  - Input array code H, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_Q(self):
		"""Test acalc compile init array types  - Input array code H, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_f(self):
		"""Test acalc compile init array types  - Input array code H, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_d(self):
		"""Test acalc compile init array types  - Input array code H, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_b(self):
		"""Test acalc compile init array types  - Input array code i, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_B(self):
		"""Test acalc compile init array types  - Input array code i, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_h(self):
		"""Test acalc compile init array types  - Input array code i, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_H(self):
		"""Test acalc compile init array types  - Input array code i, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_I(self):
		"""Test acalc compile init array types  - Input array code i, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_l(self):
		"""Test acalc compile init array types  - Input array code i, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_L(self):
		"""Test acalc compile init array types  - Input array code i, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_q(self):
		"""Test acalc compile init array types  - Input array code i, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_Q(self):
		"""Test acalc compile init array types  - Input array code i, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_f(self):
		"""Test acalc compile init array types  - Input array code i, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_d(self):
		"""Test acalc compile init array types  - Input array code i, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_b(self):
		"""Test acalc compile init array types  - Input array code I, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_B(self):
		"""Test acalc compile init array types  - Input array code I, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_h(self):
		"""Test acalc compile init array types  - Input array code I, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_H(self):
		"""Test acalc compile init array types  - Input array code I, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_i(self):
		"""Test acalc compile init array types  - Input array code I, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_l(self):
		"""Test acalc compile init array types  - Input array code I, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_L(self):
		"""Test acalc compile init array types  - Input array code I, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_q(self):
		"""Test acalc compile init array types  - Input array code I, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_Q(self):
		"""Test acalc compile init array types  - Input array code I, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_f(self):
		"""Test acalc compile init array types  - Input array code I, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_d(self):
		"""Test acalc compile init array types  - Input array code I, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_b(self):
		"""Test acalc compile init array types  - Input array code l, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_B(self):
		"""Test acalc compile init array types  - Input array code l, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_h(self):
		"""Test acalc compile init array types  - Input array code l, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_H(self):
		"""Test acalc compile init array types  - Input array code l, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_i(self):
		"""Test acalc compile init array types  - Input array code l, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_I(self):
		"""Test acalc compile init array types  - Input array code l, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_L(self):
		"""Test acalc compile init array types  - Input array code l, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_q(self):
		"""Test acalc compile init array types  - Input array code l, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_Q(self):
		"""Test acalc compile init array types  - Input array code l, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_f(self):
		"""Test acalc compile init array types  - Input array code l, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_d(self):
		"""Test acalc compile init array types  - Input array code l, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_b(self):
		"""Test acalc compile init array types  - Input array code L, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_B(self):
		"""Test acalc compile init array types  - Input array code L, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_h(self):
		"""Test acalc compile init array types  - Input array code L, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_H(self):
		"""Test acalc compile init array types  - Input array code L, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_i(self):
		"""Test acalc compile init array types  - Input array code L, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_I(self):
		"""Test acalc compile init array types  - Input array code L, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_l(self):
		"""Test acalc compile init array types  - Input array code L, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_q(self):
		"""Test acalc compile init array types  - Input array code L, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_Q(self):
		"""Test acalc compile init array types  - Input array code L, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_f(self):
		"""Test acalc compile init array types  - Input array code L, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_d(self):
		"""Test acalc compile init array types  - Input array code L, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_b(self):
		"""Test acalc compile init array types  - Input array code q, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_B(self):
		"""Test acalc compile init array types  - Input array code q, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_h(self):
		"""Test acalc compile init array types  - Input array code q, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_H(self):
		"""Test acalc compile init array types  - Input array code q, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_i(self):
		"""Test acalc compile init array types  - Input array code q, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_I(self):
		"""Test acalc compile init array types  - Input array code q, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_l(self):
		"""Test acalc compile init array types  - Input array code q, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_L(self):
		"""Test acalc compile init array types  - Input array code q, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_Q(self):
		"""Test acalc compile init array types  - Input array code q, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_f(self):
		"""Test acalc compile init array types  - Input array code q, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_d(self):
		"""Test acalc compile init array types  - Input array code q, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_b(self):
		"""Test acalc compile init array types  - Input array code Q, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_B(self):
		"""Test acalc compile init array types  - Input array code Q, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_h(self):
		"""Test acalc compile init array types  - Input array code Q, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_H(self):
		"""Test acalc compile init array types  - Input array code Q, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_i(self):
		"""Test acalc compile init array types  - Input array code Q, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_I(self):
		"""Test acalc compile init array types  - Input array code Q, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_l(self):
		"""Test acalc compile init array types  - Input array code Q, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_L(self):
		"""Test acalc compile init array types  - Input array code Q, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_q(self):
		"""Test acalc compile init array types  - Input array code Q, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_f(self):
		"""Test acalc compile init array types  - Input array code Q, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_d(self):
		"""Test acalc compile init array types  - Input array code Q, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_b(self):
		"""Test acalc compile init array types  - Input array code f, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_B(self):
		"""Test acalc compile init array types  - Input array code f, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_h(self):
		"""Test acalc compile init array types  - Input array code f, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_H(self):
		"""Test acalc compile init array types  - Input array code f, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_i(self):
		"""Test acalc compile init array types  - Input array code f, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_I(self):
		"""Test acalc compile init array types  - Input array code f, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_l(self):
		"""Test acalc compile init array types  - Input array code f, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_L(self):
		"""Test acalc compile init array types  - Input array code f, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_q(self):
		"""Test acalc compile init array types  - Input array code f, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_Q(self):
		"""Test acalc compile init array types  - Input array code f, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_d(self):
		"""Test acalc compile init array types  - Input array code f, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_b(self):
		"""Test acalc compile init array types  - Input array code d, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_B(self):
		"""Test acalc compile init array types  - Input array code d, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_h(self):
		"""Test acalc compile init array types  - Input array code d, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_H(self):
		"""Test acalc compile init array types  - Input array code d, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_i(self):
		"""Test acalc compile init array types  - Input array code d, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_I(self):
		"""Test acalc compile init array types  - Input array code d, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_l(self):
		"""Test acalc compile init array types  - Input array code d, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_L(self):
		"""Test acalc compile init array types  - Input array code d, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_q(self):
		"""Test acalc compile init array types  - Input array code d, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_Q(self):
		"""Test acalc compile init array types  - Input array code d, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_f(self):
		"""Test acalc compile init array types  - Input array code d, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_b(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code b.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('b', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_B(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code B.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('B', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_h(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code h.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('h', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_H(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code H.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('H', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_i(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code i.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('i', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_I(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code I.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('I', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_l(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code l.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('l', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_L(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code L.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('L', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_q(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code q.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_Q(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code Q.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('Q', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_f(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code f.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('f', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_bytes_d(self):
		"""Test acalc compile init array types  - Input array code bytes, output array code d.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array('d', [0] * len(self.data))
		

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_b_bytes(self):
		"""Test acalc compile init array types  - Input array code b, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('b', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_B_bytes(self):
		"""Test acalc compile init array types  - Input array code B, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('B', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_h_bytes(self):
		"""Test acalc compile init array types  - Input array code h, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('h', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_H_bytes(self):
		"""Test acalc compile init array types  - Input array code H, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('H', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_i_bytes(self):
		"""Test acalc compile init array types  - Input array code i, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('i', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_I_bytes(self):
		"""Test acalc compile init array types  - Input array code I, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('I', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_l_bytes(self):
		"""Test acalc compile init array types  - Input array code l, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('l', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_L_bytes(self):
		"""Test acalc compile init array types  - Input array code L, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('L', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_q_bytes(self):
		"""Test acalc compile init array types  - Input array code q, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_Q_bytes(self):
		"""Test acalc compile init array types  - Input array code Q, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('Q', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_f_bytes(self):
		"""Test acalc compile init array types  - Input array code f, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('f', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_init_mismatch_arraytypes_d_bytes(self):
		"""Test acalc compile init array types  - Input array code d, output array code bytes.
		"""
		self.DataLen = 1000
		self.data = array.array('d', [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array('B', [0] * len(self.data))
		self.dataout = bytes(self.dataout)

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



##############################################################################


##############################################################################
class acalcccomp_platform_math_b(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code b.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_B(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code B.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_h(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code h.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_H(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code H.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_i(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code i.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_I(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code I.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_l(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code l.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_L(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code L.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_q(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code q.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_Q(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code Q.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_f(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code f.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_d(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code d.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_platform_math_bytes(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code bytes.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################


##############################################################################
class acalcccomp_calc_comp_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code b.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code b.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code b.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code B.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code B.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code B.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code h.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code h.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code h.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code H.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code H.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code H.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code i.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code i.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code i.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code I.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code I.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code I.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code l.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code l.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code l.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code L.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code L.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code L.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code q.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code q.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code Q.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code Q.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code Q.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code f.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code f.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code f.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code d.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code d.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code d.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code bytes.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code bytes.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code bytes.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterFuncCalls_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterFuncCalls_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterFuncCalls_00(self):
		"""Test acalc compile _FilterFuncCalls - this should pass without a function call  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength)


	########################################################
	def test_compile__FilterFuncCalls_01(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_02(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_03(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x)  - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'abs', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_04(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x)  - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('pushvar', 'math', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_05(self):
		"""Test acalc compile _FilterFuncCalls - abs(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_06(self):
		"""Test acalc compile _FilterFuncCalls - math.sin(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_07(self):
		"""Test acalc compile _FilterFuncCalls - 1 + abs(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'abs', False), ('abs', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


	########################################################
	def test_compile__FilterFuncCalls_08(self):
		"""Test acalc compile _FilterFuncCalls - 1 + math.sin(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushvar', 'math', False), ('math.sin', None, True), ('pushconst', 1, False), 
			('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		result = self.eqn._FilterFuncCalls(nodelist)

		self.assertEqual(len(result), nodelength - 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code b.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code b.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code b.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code b.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code b.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code b.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code b.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code b.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code b.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code B.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code B.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code B.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code B.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code B.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code B.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code B.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code B.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code B.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code h.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code h.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code h.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code h.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code h.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code h.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code h.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code h.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code h.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code H.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code H.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code H.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code H.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code H.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code H.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code H.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code H.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code H.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code i.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code i.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code i.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code i.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code i.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code i.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code i.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code i.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code i.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code I.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code I.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code I.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code I.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code I.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code I.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code I.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code I.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code I.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code l.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code l.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code l.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code l.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code l.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code l.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code l.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code l.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code l.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code L.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code L.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code L.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code L.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code L.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code L.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code L.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code L.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code L.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code q.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code q.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code q.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code q.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code q.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code q.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code q.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code q.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code q.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code Q.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code Q.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code Q.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code Q.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code Q.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code Q.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code Q.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code Q.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code Q.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code f.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code f.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code f.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code f.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code f.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code f.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code f.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code f.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code f.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code d.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code d.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code d.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code d.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code d.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code d.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code d.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code d.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code d.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code bytes.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code bytes.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code bytes.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code bytes.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code bytes.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code bytes.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code bytes.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code bytes.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code bytes.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code b.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code B.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code h.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code H.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code i.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code I.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code l.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code L.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code q.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code Q.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_func_float_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_float_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_func_float_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_01(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x)  - Array code f.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_03(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.sin(x) + 2  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidmath.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.sin.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_func_float_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_float_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_func_float_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_01(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x)  - Array code d.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_03(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.sin(x) + 2  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidmath.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.sin.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code bytes.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code b.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code B.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code h.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code H.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code i.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code I.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code l.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code L.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code q.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code Q.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code f.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), float)
		self.assertIs(type(result[2].param), float)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code f.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), float)
		self.assertIs(type(result[2].param), float)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code d.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), float)
		self.assertIs(type(result[2].param), float)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code d.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), float)
		self.assertIs(type(result[2].param), float)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code bytes.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), int)
		self.assertIs(type(result[2].param), int)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code b.
		"""
		MaxLimit = arrayfunc.arraylimits.b_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code b.
		"""
		MinLimit = arrayfunc.arraylimits.b_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code B.
		"""
		MaxLimit = arrayfunc.arraylimits.B_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code B.
		"""
		MinLimit = arrayfunc.arraylimits.B_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code h.
		"""
		MaxLimit = arrayfunc.arraylimits.h_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code h.
		"""
		MinLimit = arrayfunc.arraylimits.h_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code H.
		"""
		MaxLimit = arrayfunc.arraylimits.H_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code H.
		"""
		MinLimit = arrayfunc.arraylimits.H_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code i.
		"""
		MaxLimit = arrayfunc.arraylimits.i_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code i.
		"""
		MinLimit = arrayfunc.arraylimits.i_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code I.
		"""
		MaxLimit = arrayfunc.arraylimits.I_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code I.
		"""
		MinLimit = arrayfunc.arraylimits.I_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code l.
		"""
		MaxLimit = arrayfunc.arraylimits.l_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code l.
		"""
		MinLimit = arrayfunc.arraylimits.l_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code L.
		"""
		MaxLimit = arrayfunc.arraylimits.L_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code L.
		"""
		MinLimit = arrayfunc.arraylimits.L_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code q.
		"""
		MaxLimit = arrayfunc.arraylimits.q_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code q.
		"""
		MinLimit = arrayfunc.arraylimits.q_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code Q.
		"""
		MaxLimit = arrayfunc.arraylimits.Q_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code Q.
		"""
		MinLimit = arrayfunc.arraylimits.Q_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code bytes.
		"""
		MaxLimit = arrayfunc.arraylimits.B_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code bytes.
		"""
		MinLimit = arrayfunc.arraylimits.B_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code b.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code b.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code B.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code B.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code h.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code h.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code H.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code H.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code i.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code i.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code I.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code I.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code l.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code l.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code L.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code L.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code q.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code Q.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code Q.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code f.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code f.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code f.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code d.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code d.
		"""
		nodedata = [('pushconst', 2.0, False), ('pusharray', 'x', False), 
			('pushconst', 1.0, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code d.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__CheckStack_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code bytes.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code bytes.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code b.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code b.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code b.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code b.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code b.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code B.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code B.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code B.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code B.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code B.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code h.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code h.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code h.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code h.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code h.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code H.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code H.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code H.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code H.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code H.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code i.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code i.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code i.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code i.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code i.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code I.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code I.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code I.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code I.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code I.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code l.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code l.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code l.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code l.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code l.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code L.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code L.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code L.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code L.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code L.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code Q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code Q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code Q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code Q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code Q.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code f.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code f.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code f.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code f.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code f.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code d.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code d.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code d.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code d.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code d.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code bytes.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code bytes.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code bytes.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code bytes.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code bytes.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_b(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'b'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code b.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_B(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code B.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_h(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'h'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code h.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_H(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'H'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code H.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_i(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'i'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code i.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_I(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'I'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code I.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_l(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'l'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code l.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_L(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'L'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code L.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code q.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_Q(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'Q'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code Q.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_f(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'f'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code f.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_d(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'd'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code d.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_bytes(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = 'B'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		self.data = bytes(self.data)
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		self.dataout = bytes(self.dataout)
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code bytes.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################


##############################################################################
if __name__ == '__main__':
    unittest.main()

##############################################################################
