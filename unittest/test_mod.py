#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Module:   test_mod.py
# Purpose:  arrayfunc unit test.
# Language: Python 3.4
# Date:     09-Dec-2017.
# Ver:      01-Oct-2021.
#
###############################################################################
#
#   Copyright 2014 - 2021    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################
"""This conducts unit tests for mod.
"""

##############################################################################
import sys

import array
import itertools
import math
import operator
import platform
import copy

import unittest

import arrayfunc

##############################################################################

##############################################################################

# The following code is all auto-generated.




##############################################################################
class mod_general_int_even_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_fullrange_even_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_fullrange(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_fullrange_odd_arraysize_b(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'b' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'b' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'b' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'b' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.b_min
			maxval = arrayfunc.arraylimits.b_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_fullrange(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'b' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code b.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvalx] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('b', [testvaly] * self.testdatasize)
				dataout = array.array('b', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code b.
		"""
		data1 = array.array('b', self.datax)
		data2 = array.array('b', self.datay)
		dataout = array.array('b', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_b(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('b', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('b', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code b.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code b.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code b.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code b.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code b.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code b.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code b.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code b.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code b.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code b.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code b.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code b.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_b(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('b', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('b', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('b', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code b.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code b.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code b.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code b.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code b.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code b.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code b.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code b.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code b.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code b.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code b.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_b(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.b_max
		self.MinLimit = arrayfunc.arraylimits.b_min


		self.inparray1amax = array.array('b', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('b', [0] * arraysize)
		self.plus1array = array.array('b', [1] * arraysize)

		self.dataout = array.array('b', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_b(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.b_max
		self.MinLimit = arrayfunc.arraylimits.b_min


		self.inparray1amax = array.array('b', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('b', [0] * arraysize)
		self.plus1array = array.array('b', [1] * arraysize)

		self.dataout = array.array('b', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code b.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_fullrange_even_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_fullrange(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_fullrange_odd_arraysize_B(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'B' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'B' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'B' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'B' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.B_min
			maxval = arrayfunc.arraylimits.B_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_fullrange(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'B' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code B.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvalx] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('B', [testvaly] * self.testdatasize)
				dataout = array.array('B', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code B.
		"""
		data1 = array.array('B', self.datax)
		data2 = array.array('B', self.datay)
		dataout = array.array('B', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_B(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('B', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('B', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code B.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code B.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code B.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code B.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code B.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code B.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code B.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code B.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code B.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code B.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code B.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code B.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_B(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('B', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('B', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('B', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code B.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code B.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code B.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code B.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code B.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code B.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code B.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code B.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code B.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code B.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code B.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_B(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min


		self.inparray1amax = array.array('B', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('B', [0] * arraysize)
		self.plus1array = array.array('B', [1] * arraysize)

		self.dataout = array.array('B', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_B(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.B_max
		self.MinLimit = arrayfunc.arraylimits.B_min


		self.inparray1amax = array.array('B', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('B', [0] * arraysize)
		self.plus1array = array.array('B', [1] * arraysize)

		self.dataout = array.array('B', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code B.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_h(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'h' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'h' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'h' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'h' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'h' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code h.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_h(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'h' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'h' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'h' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'h' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'h' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code h.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_h(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'h' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'h' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'h' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'h' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'h' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code h.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_h(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'h' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'h' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'h' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'h' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'h' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code h.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvalx] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('h', [testvaly] * self.testdatasize)
				dataout = array.array('h', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code h.
		"""
		data1 = array.array('h', self.datax)
		data2 = array.array('h', self.datay)
		dataout = array.array('h', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_h(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('h', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('h', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code h.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code h.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code h.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code h.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code h.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code h.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code h.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code h.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code h.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code h.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code h.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code h.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_h(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('h', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('h', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('h', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code h.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code h.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code h.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code h.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code h.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code h.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code h.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code h.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code h.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code h.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code h.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_h(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.h_max
		self.MinLimit = arrayfunc.arraylimits.h_min


		self.inparray1amax = array.array('h', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('h', [0] * arraysize)
		self.plus1array = array.array('h', [1] * arraysize)

		self.dataout = array.array('h', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_h(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.h_max
		self.MinLimit = arrayfunc.arraylimits.h_min


		self.inparray1amax = array.array('h', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('h', [0] * arraysize)
		self.plus1array = array.array('h', [1] * arraysize)

		self.dataout = array.array('h', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code h.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_H(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'H' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'H' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'H' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'H' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.H_min
			maxval = arrayfunc.arraylimits.H_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'H' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code H.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_H(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'H' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'H' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'H' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'H' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.H_min
			maxval = arrayfunc.arraylimits.H_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'H' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code H.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_H(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'H' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'H' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'H' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'H' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.H_min
			maxval = arrayfunc.arraylimits.H_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'H' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code H.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_H(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'H' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'H' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'H' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'H' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.H_min
			maxval = arrayfunc.arraylimits.H_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'H' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code H.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvalx] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('H', [testvaly] * self.testdatasize)
				dataout = array.array('H', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code H.
		"""
		data1 = array.array('H', self.datax)
		data2 = array.array('H', self.datay)
		dataout = array.array('H', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_H(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('H', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('H', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code H.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code H.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code H.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code H.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code H.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code H.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code H.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code H.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code H.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code H.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code H.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code H.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_H(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('H', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('H', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('H', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code H.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code H.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code H.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code H.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code H.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code H.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code H.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code H.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code H.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code H.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code H.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_H(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.H_max
		self.MinLimit = arrayfunc.arraylimits.H_min


		self.inparray1amax = array.array('H', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('H', [0] * arraysize)
		self.plus1array = array.array('H', [1] * arraysize)

		self.dataout = array.array('H', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_H(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.H_max
		self.MinLimit = arrayfunc.arraylimits.H_min


		self.inparray1amax = array.array('H', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('H', [0] * arraysize)
		self.plus1array = array.array('H', [1] * arraysize)

		self.dataout = array.array('H', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code H.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_i(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'i' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'i' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'i' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'i' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'i' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code i.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_i(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'i' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'i' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'i' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'i' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'i' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code i.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_i(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'i' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'i' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'i' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'i' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'i' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code i.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_i(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'i' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'i' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'i' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'i' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'i' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code i.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvalx] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('i', [testvaly] * self.testdatasize)
				dataout = array.array('i', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code i.
		"""
		data1 = array.array('i', self.datax)
		data2 = array.array('i', self.datay)
		dataout = array.array('i', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_i(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('i', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('i', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code i.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code i.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code i.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code i.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code i.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code i.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code i.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code i.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code i.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code i.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code i.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code i.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_i(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('i', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('i', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('i', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code i.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code i.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code i.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code i.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code i.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code i.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code i.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code i.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code i.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code i.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code i.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_i(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.i_max
		self.MinLimit = arrayfunc.arraylimits.i_min


		self.inparray1amax = array.array('i', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('i', [0] * arraysize)
		self.plus1array = array.array('i', [1] * arraysize)

		self.dataout = array.array('i', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_i(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.i_max
		self.MinLimit = arrayfunc.arraylimits.i_min


		self.inparray1amax = array.array('i', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('i', [0] * arraysize)
		self.plus1array = array.array('i', [1] * arraysize)

		self.dataout = array.array('i', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code i.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_I(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'I' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'I' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'I' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'I' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.I_min
			maxval = arrayfunc.arraylimits.I_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'I' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code I.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_I(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'I' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'I' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'I' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'I' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.I_min
			maxval = arrayfunc.arraylimits.I_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'I' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code I.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_I(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'I' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'I' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'I' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'I' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.I_min
			maxval = arrayfunc.arraylimits.I_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'I' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code I.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_I(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'I' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'I' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'I' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'I' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.I_min
			maxval = arrayfunc.arraylimits.I_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'I' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code I.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvalx] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('I', [testvaly] * self.testdatasize)
				dataout = array.array('I', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code I.
		"""
		data1 = array.array('I', self.datax)
		data2 = array.array('I', self.datay)
		dataout = array.array('I', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_I(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('I', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('I', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code I.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code I.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code I.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code I.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code I.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code I.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code I.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code I.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code I.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code I.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code I.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code I.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_I(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('I', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('I', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('I', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code I.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code I.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code I.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code I.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code I.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code I.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code I.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code I.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code I.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code I.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code I.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_I(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.I_max
		self.MinLimit = arrayfunc.arraylimits.I_min


		self.inparray1amax = array.array('I', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('I', [0] * arraysize)
		self.plus1array = array.array('I', [1] * arraysize)

		self.dataout = array.array('I', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_I(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.I_max
		self.MinLimit = arrayfunc.arraylimits.I_min


		self.inparray1amax = array.array('I', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('I', [0] * arraysize)
		self.plus1array = array.array('I', [1] * arraysize)

		self.dataout = array.array('I', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code I.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_l(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'l' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'l' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'l' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'l' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.l_min
			maxval = arrayfunc.arraylimits.l_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'l' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code l.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_l(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'l' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'l' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'l' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'l' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.l_min
			maxval = arrayfunc.arraylimits.l_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'l' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code l.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_l(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'l' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'l' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'l' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'l' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.l_min
			maxval = arrayfunc.arraylimits.l_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'l' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code l.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_l(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'l' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'l' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'l' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'l' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.l_min
			maxval = arrayfunc.arraylimits.l_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'l' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code l.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvalx] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('l', [testvaly] * self.testdatasize)
				dataout = array.array('l', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code l.
		"""
		data1 = array.array('l', self.datax)
		data2 = array.array('l', self.datay)
		dataout = array.array('l', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_l(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('l', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('l', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code l.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code l.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code l.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code l.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code l.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code l.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code l.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code l.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code l.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code l.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code l.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code l.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_l(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('l', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('l', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('l', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code l.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code l.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code l.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code l.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code l.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code l.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code l.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code l.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code l.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code l.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code l.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_l(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.l_max
		self.MinLimit = arrayfunc.arraylimits.l_min


		self.inparray1amax = array.array('l', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('l', [0] * arraysize)
		self.plus1array = array.array('l', [1] * arraysize)

		self.dataout = array.array('l', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_l(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.l_max
		self.MinLimit = arrayfunc.arraylimits.l_min


		self.inparray1amax = array.array('l', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('l', [0] * arraysize)
		self.plus1array = array.array('l', [1] * arraysize)

		self.dataout = array.array('l', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code l.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_L(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'L' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'L' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'L' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'L' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.L_min
			maxval = arrayfunc.arraylimits.L_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'L' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code L.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_L(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'L' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'L' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'L' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'L' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.L_min
			maxval = arrayfunc.arraylimits.L_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'L' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code L.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_L(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'L' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'L' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'L' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'L' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.L_min
			maxval = arrayfunc.arraylimits.L_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'L' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code L.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_L(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'L' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'L' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'L' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'L' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.L_min
			maxval = arrayfunc.arraylimits.L_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'L' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code L.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvalx] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('L', [testvaly] * self.testdatasize)
				dataout = array.array('L', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code L.
		"""
		data1 = array.array('L', self.datax)
		data2 = array.array('L', self.datay)
		dataout = array.array('L', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_L(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('L', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('L', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code L.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code L.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code L.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code L.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code L.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code L.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code L.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code L.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code L.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code L.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code L.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code L.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_L(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('L', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('L', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('L', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code L.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code L.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code L.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code L.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code L.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code L.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code L.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code L.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code L.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code L.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code L.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_L(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.L_max
		self.MinLimit = arrayfunc.arraylimits.L_min


		self.inparray1amax = array.array('L', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('L', [0] * arraysize)
		self.plus1array = array.array('L', [1] * arraysize)

		self.dataout = array.array('L', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_L(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.L_max
		self.MinLimit = arrayfunc.arraylimits.L_min


		self.inparray1amax = array.array('L', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('L', [0] * arraysize)
		self.plus1array = array.array('L', [1] * arraysize)

		self.dataout = array.array('L', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code L.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.q_min
			maxval = arrayfunc.arraylimits.q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.q_min
			maxval = arrayfunc.arraylimits.q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.q_min
			maxval = arrayfunc.arraylimits.q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.q_min
			maxval = arrayfunc.arraylimits.q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvalx] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('q', [testvaly] * self.testdatasize)
				dataout = array.array('q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code q.
		"""
		data1 = array.array('q', self.datax)
		data2 = array.array('q', self.datay)
		dataout = array.array('q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_q(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('q', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('q', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code q.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code q.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code q.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code q.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code q.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_q(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('q', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('q', [x for (x,y) in zip(itertools.cycle([-2,-1,1,2]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('q', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code q.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_q(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.q_max
		self.MinLimit = arrayfunc.arraylimits.q_min


		self.inparray1amax = array.array('q', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('q', [0] * arraysize)
		self.plus1array = array.array('q', [1] * arraysize)

		self.dataout = array.array('q', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_q(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.q_max
		self.MinLimit = arrayfunc.arraylimits.q_min


		self.inparray1amax = array.array('q', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('q', [0] * arraysize)
		self.plus1array = array.array('q', [1] * arraysize)

		self.dataout = array.array('q', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_Q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'Q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'Q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'Q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'Q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.Q_min
			maxval = arrayfunc.arraylimits.Q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'Q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code Q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_Q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'Q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'Q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'Q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'Q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.Q_min
			maxval = arrayfunc.arraylimits.Q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'Q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code Q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_Q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'Q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'Q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'Q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'Q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.Q_min
			maxval = arrayfunc.arraylimits.Q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'Q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code Q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_Q(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'Q' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'Q' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'Q' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'Q' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.Q_min
			maxval = arrayfunc.arraylimits.Q_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'Q' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code Q.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvalx] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('Q', [testvaly] * self.testdatasize)
				dataout = array.array('Q', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code Q.
		"""
		data1 = array.array('Q', self.datax)
		data2 = array.array('Q', self.datay)
		dataout = array.array('Q', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_Q(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		self.testarray2 = array.array('Q', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('Q', itertools.repeat(0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('d', [float(x) for x in self.testarray1])
		self.badarray2 = array.array('d', [float(x) for x in self.testarray2])

		self.baddataout = array.array('d', [float(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code Q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code Q.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code Q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code Q.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code Q.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code Q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code Q.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code Q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code Q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code Q.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code Q.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code Q.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_Q(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('Q', [100,101,102,103,104,105,106,107,108,109])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('Q', [x for (x,y) in zip(itertools.cycle([1,3,4]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('Q', itertools.repeat(0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code Q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code Q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code Q.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code Q.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code Q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code Q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code Q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code Q.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code Q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code Q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code Q.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_Q(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.Q_max
		self.MinLimit = arrayfunc.arraylimits.Q_min


		self.inparray1amax = array.array('Q', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('Q', [0] * arraysize)
		self.plus1array = array.array('Q', [1] * arraysize)

		self.dataout = array.array('Q', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################




##############################################################################
class overflow_signed_divzero_errors_Q(unittest.TestCase):
	"""Test mod for value divide by zero with overflow checking disabled.
	param_overflow_mod_divzero_errors_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.Q_max
		self.MinLimit = arrayfunc.arraylimits.Q_min


		self.inparray1amax = array.array('Q', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('Q', [0] * arraysize)
		self.plus1array = array.array('Q', [1] * arraysize)

		self.dataout = array.array('Q', itertools.repeat(0, arraysize))


	########################################################
	def test_mod_array_num_none_b1(self):
		"""Test mod as *array-num-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, matherrors=True)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0, self.dataout, matherrors=True)


	########################################################
	def test_mod_num_array_none_b3(self):
		"""Test mod as *num-array-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, matherrors=True)


	########################################################
	def test_mod_num_array_array_b4(self):
		"""Test mod as *num-array-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout, matherrors=True)


	########################################################
	def test_mod_array_array_none_b5(self):
		"""Test mod as *array-array-none* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, matherrors=True)


	########################################################
	def test_mod_array_array_array_b6(self):
		"""Test mod as *array-array-array* for max value % 0 - Array code Q.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout, matherrors=True)



##############################################################################



##############################################################################
class mod_general_int_even_arraysize_f(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'f' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'f' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'f' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'f' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.f_min
			maxval = arrayfunc.arraylimits.f_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'f' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code f.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_f(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'f' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'f' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'f' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'f' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.f_min
			maxval = arrayfunc.arraylimits.f_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'f' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code f.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_f(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'f' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'f' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'f' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'f' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.f_min
			maxval = arrayfunc.arraylimits.f_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'f' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code f.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_f(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'f' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'f' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'f' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'f' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.f_min
			maxval = arrayfunc.arraylimits.f_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'f' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code f.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvalx] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('f', [testvaly] * self.testdatasize)
				dataout = array.array('f', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code f.
		"""
		data1 = array.array('f', self.datax)
		data2 = array.array('f', self.datay)
		dataout = array.array('f', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_f(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.testarray2 = array.array('f', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('i', [int(x) for x in self.testarray1])
		self.badarray2 = array.array('i', [int(x) for x in self.testarray2])

		self.baddataout = array.array('i', [int(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code f.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code f.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code f.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code f.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code f.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code f.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code f.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code f.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code f.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code f.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code f.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code f.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_f(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('f', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code f.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code f.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code f.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code f.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code f.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code f.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code f.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code f.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code f.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code f.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code f.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_f(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.f_max
		self.MinLimit = arrayfunc.arraylimits.f_min


		self.inparray1amax = array.array('f', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('f', [0.0] * arraysize)
		self.plus1array = array.array('f', [1.0] * arraysize)

		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1.0)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0.0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1.0, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0.0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0.0 - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################



##############################################################################
class mod_NaN_errors_f(unittest.TestCase):
	"""Test mod for basic general function operation using parameter nan.
	nan_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('f', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('f', [float('nan')] * arraysize)



	########################################################
	def test_mod_NaN_array_num_none_a1(self):
		"""Test mod as *array-num-none* for nan - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_NaN_array_num_none_a2(self):
		"""Test mod as *array-num-none* for nan with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_num_array_b1(self):
		"""Test mod as *array-num-array* for nan - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_NaN_array_num_array_b2(self):
		"""Test mod as *array-num-array* for nan with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_num_array_none_c1(self):
		"""Test mod as *num-array-none* for nan - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_NaN_num_array_none_c2(self):
		"""Test mod as *num-array-none* for nan with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				expected = [testval % x for x in self.errordata]

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_num_array_array_d1(self):
		"""Test mod as *num-array-array* for nan - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_NaN_num_array_array_d2(self):
		"""Test mod as *num-array-array* for nan with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [testval % x for x in self.errordata]

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_array_none_e1(self):
		"""Test mod as *array-array-none* for nan - Array code f.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_NaN_array_array_none_e2(self):
		"""Test mod as *array-array-none* for nan with error check off - Array code f.
		"""
		expected = [y % x for x,y in zip(self.errordata, self.dataok1)]

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_array_array_f1(self):
		"""Test mod as *array-array-array* for nan - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_NaN_array_array_array_f2(self):
		"""Test mod as *array-array-array* for nan with error check off - Array code f.
		"""
		expected = [y % x for x,y in zip(self.errordata, self.dataok1)]

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################



##############################################################################
class mod_inf_errors_f(unittest.TestCase):
	"""Test mod for basic general function operation using parameter inf.
	inf_mod_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('f', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('f', [float('inf')] * arraysize)



	########################################################
	def test_mod_inf_array_num_none_a1(self):
		"""Test mod as *array-num-none* for inf - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_inf_array_num_none_a2(self):
		"""Test mod as *array-num-none* for inf with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_num_array_b1(self):
		"""Test mod as *array-num-array* for inf - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_inf_array_num_array_b2(self):
		"""Test mod as *array-num-array* for inf with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_num_array_none_c1(self):
		"""Test mod as *num-array-none* for inf - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_inf_num_array_none_c2(self):
		"""Test mod as *num-array-none* for inf with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_num_array_array_d1(self):
		"""Test mod as *num-array-array* for inf - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_inf_num_array_array_d2(self):
		"""Test mod as *num-array-array* for inf with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_array_none_e1(self):
		"""Test mod as *array-array-none* for inf - Array code f.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_inf_array_array_none_e2(self):
		"""Test mod as *array-array-none* for inf with error check off - Array code f.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_array_array_f1(self):
		"""Test mod as *array-array-array* for inf - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_inf_array_array_array_f2(self):
		"""Test mod as *array-array-array* for inf with error check off - Array code f.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################



##############################################################################
class mod_ninf_errors_f(unittest.TestCase):
	"""Test mod for basic general function operation using parameter -inf.
	inf_mod_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('f', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('f', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('f', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('f', [float('-inf')] * arraysize)



	########################################################
	def test_mod_ninf_array_num_none_a1(self):
		"""Test mod as *array-num-none* for -inf - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_ninf_array_num_none_a2(self):
		"""Test mod as *array-num-none* for -inf with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_num_array_b1(self):
		"""Test mod as *array-num-array* for -inf - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_ninf_array_num_array_b2(self):
		"""Test mod as *array-num-array* for -inf with error check off - Array code f.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_num_array_none_c1(self):
		"""Test mod as *num-array-none* for -inf - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_ninf_num_array_none_c2(self):
		"""Test mod as *num-array-none* for -inf with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_num_array_array_d1(self):
		"""Test mod as *num-array-array* for -inf - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_ninf_num_array_array_d2(self):
		"""Test mod as *num-array-array* for -inf with error check off - Array code f.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_array_none_e1(self):
		"""Test mod as *array-array-none* for -inf - Array code f.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_ninf_array_array_none_e2(self):
		"""Test mod as *array-array-none* for -inf with error check off - Array code f.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_array_array_f1(self):
		"""Test mod as *array-array-array* for -inf - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_ninf_array_array_array_f2(self):
		"""Test mod as *array-array-array* for -inf with error check off - Array code f.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################



##############################################################################
class mod_general_int_even_arraysize_d(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'd' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'd' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'd' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'd' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.d_min
			maxval = arrayfunc.arraylimits.d_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'd' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code d.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_int_odd_arraysize_d(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'd' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'd' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'd' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'd' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.d_min
			maxval = arrayfunc.arraylimits.d_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_int(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'd' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code d.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_even_arraysize_d(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'd' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'd' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'even' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'even' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'd' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'd' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.d_min
			maxval = arrayfunc.arraylimits.d_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'd' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code d.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_general_special_odd_arraysize_d(unittest.TestCase):
	"""Test mod for basic general function operation using numeric data.
	test_op_templ
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))


	##############################################################################
	def FloatListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			# NaN cannot be compared using normal means.
			if math.isnan(dataoutitem) and math.isnan(expecteditem):
				pass
			# Anything else can be compared normally.
			else:
				if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
					raise self.failureException('%0.3f != %0.3f at index %d' % (expecteditem, dataoutitem, index))


	##############################################################################
	def IntListassertEqual(self, dataout, expected, msg=None):
		"""This function is patched into assertEqual to allow testing for
		lists of integers.
		"""
		for index, (dataoutitem, expecteditem) in enumerate(zip(dataout, expected)):
			if expecteditem != dataoutitem:
				raise self.failureException('%d != %d at index %d' % (expecteditem, dataoutitem, index))


	########################################################
	def inttruediv(self, x, y):
		"""Perform the math operation. This needs to be specially handled
		for truediv on large signed integer arrays. This is because of a 
		combination of factors. Python will produce a floating point result, 
		but we we want an integer result when using integer arrays. If we 
		simply convert the result back to integer then we lose precision on
		large integers, introducing errors. If we try to emulate it using
		floor division, then when using mixed positive and negative inputs
		the result is rounded away from zero, producing an incorrect result.
		So, we need to take the absolute value, then do floor division, then
		put the correct sign back into the result.
		"""
		# This is intended to catch template errors and should never 
		# occur in normal usage. 

		# For true division on integer arrays.
		# For when signs are opposite in signed arrays.
		if ((x < 0) ^ (y < 0)):
			return -(abs(x) // abs(y))
		else:
			return x // y


	########################################################
	def filtertestdata(self, opvalues, minint, maxint, opname):
		"""Filter the test data for combinations that might cause errors.
		Filtering for pow is handled elsewhere.
		"""
		# Avoid division by zero
		if opname == 'floordiv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x // y) <= maxint) and ((x // y) >= minint))]
		elif opname == 'mod':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and ((x % y) <= maxint) and ((x % y) >= minint))]
		# Truediv needs special handling for integer because the C function does 
		# not do actual truediv for integer.
		elif opname == 'truediv':
			checkedvalues = [(x,y) for x,y in opvalues if ((y != 0) and (self.inttruediv(x, y) <= maxint) and (self.inttruediv(x, y) >= minint))]
		elif opname == 'pow':
			if 'd' in ('f', 'd'):
				checkedvalues = [(x, y) for x,y in opvalues if ((not((x == 0) and (y < 0))) and (minint <= (x**y) <= maxint))]
			else:
				checkedvalues = [(x, y) for x,y in opvalues if (y >= 0) and (minint <= (x**y) <= maxint)]
		# Anything else. Note that since code generation is template driven the function used
		# here may not be valid if one of the other cases above is used.
		else:
			checkedvalues = [(x,y) for x,y in opvalues if (operator.mod(x, y) <= maxint) and (operator.mod(x, y) >= minint)]

		return checkedvalues



	########################################################
	def gendata_special(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		# Make sure that we have coverage for data around the maximum, minimum, and zero
		# points, which we might otherwise not have with larger data sizes.
		halfpoint = (maxint + minint) // 2
		specialvals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(specialvals, specialvals))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		checkedvalues.sort()

		return checkedvalues


	########################################################
	def gendata_specialpow(self, minint, maxint, opname):
		""" Generate data for special cases which might cause problems. 
		This one handles the data for pow only.
		For integers these will be minimum and maximum values, as well as around 
		the zero point.
		"""
		halfpoint = (maxint + minint) // 2
		basevals = [minint, minint + 1, minint + 2, minint + 3, 
					maxint - 3, maxint - 2, maxint - 1, maxint,
					halfpoint - 3, halfpoint - 2, halfpoint - 1, halfpoint, 
					halfpoint + 1, halfpoint + 2, halfpoint + 3, halfpoint + 4]

		# Raise to the power of 0 or 1.
		zerovals = [(x,0) for x in basevals]
		onevals = [(x,1) for x in basevals]

		# Raise 1 or zero to a power. Make sure we don't have negative powers.
		zerovals2 = [(0,x) for x in basevals if x >= 0]
		onevals2 = [(1,x) for x in basevals if x >= 0]

		# Raise some simple values to some common powers.
		if minint < 0:
			minstart = -3
		else:
			minstart = 0
		simplerange = list(range(minstart, 4))
		simplevals = list(itertools.product(simplerange, [0, 1, 2, 3, 4]))

		# These pairs were found to cause problems with some edge cases.
		# They all produce maximum negative integer for certain array types.
		# They represent tests for a variety of array types and have to be
		# filtered for each array code. 
		limitpairs = [(-2, 7), (-2, 15), (-8, 5), (-32, 3), (-2, 31),
			(-2, 63), (-8, 21), (-127, 9), (-512, 7), (-2097152, 3)]

		# Combine them all together.
		allvals = zerovals + onevals + zerovals2 + onevals2 + simplevals + limitpairs

		# Now filter them.
		checkedvalues = self.filtertestdata(allvals, minint, maxint, opname)
		
		return checkedvalues


	########################################################
	def gendata_pow(self, minint, maxint, opname):
		"""Generate data for general testing. This is specifically for pow as
		that operation has special requirements. 
		"""
		# We need two values for lval ** rval. The left hand one can be no bigger
		# than the square root of the maximum value in order to fit within the
		# data range (lval ** 2).
		lval = int(math.sqrt(maxint))

		stepcount = lval // 256
		stepcount = max(stepcount, 1)

		if minint < 0:
			lvalstart = -lval
		else:
			lvalstart = 0
		lvalspread = list(range(lvalstart, lval, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 32768):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			lvalspread.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			lvalspread = list(set(lvalspread))

		lvalspread.sort()

		# Take a few values which we will add back in later.
		lvalcentre = len(lvalspread) // 2
		extralvals = lvalspread[2:4] + lvalspread[-4:-2] + lvalspread[lvalcentre : lvalcentre + 2]

		# The right hand one (power to raise by) can be no bigger than 'x' where
		# 2 ** x. and the result is the maximum integer value.
		raisevals = {127 : 7, 255 : 8, 32767 : 15, 65535 : 16, 
			2147483647 : 31, 4294967295 : 32, 
			9223372036854775807 : 63, 18446744073709551615 : 64}
		rval = raisevals[maxint]

		# We start the range at 2 because 0 and 1 are trivial and we don't want
		# too many of them in the data mix.
		rvalspread = list(range(2, rval))


		# Create the combinations
		opvalues = list(itertools.product(lvalspread, rvalspread))

		# Filter out the values which would go out of range.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)
		

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		# Create the additional values involving the trivial cases of raise
		# to the power of 0 or 1.
		additionalvals = list(itertools.product(extralvals, [0, 1]))
		selectedvals.extend(additionalvals)

		selectedvals.sort()

		return selectedvals


	########################################################
	def gendata_int(self, minint, maxint, opname):
		"""Generate data for general testing. This does not worry about edge case
		data. Edge cases must be created and tested separately. This function 
		generates a wide selection of data over the numeric range. 
		"""
		# This will generate a selection of data spread over most of the integer 
		# while giving the same amount of data for each data type.
		intrange = maxint - minint 
		stepcount = intrange // 256
		stepcount = max(stepcount, 1)
		
		spreaddata = list(range(minint, maxint + 1, stepcount))

		# Make sure we have a good selection of smaller values as well.
		if (maxint > 256):
			if minint < 0:
				mindata = -128
				maxdata = 127
			else:
				mindata = 0
				maxdata = 255

			spreaddata.extend(range(mindata, maxdata, 3))
			# Remove duplicates.
			spreaddata = list(set(spreaddata))

		# Sort the data out in order.
		spreaddata.sort()

		# Trim down the size of the sample.
		selectedspread = spreaddata[::3]

		# Create combinations of all of these values.
		opvalues = list(itertools.product(selectedspread, selectedspread))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		# Now pick a smaller and more reasonable size selection over the full range.
		skipsize = len(checkedvalues) // 256
		skipsize = max(skipsize, 1)
		selectedvals = checkedvalues[::skipsize]

		return selectedvals


	########################################################
	def gendata_fullrange(self, minint, maxint, opname):
		"""Generate data for general testing. Generate all combinations of data
		that do not result in an overflow. This should only be used for small integers
		as otherwise the amount of data generated is excessive.
		This version does handle pow (**) as well as other operations.
		"""
		spreaddata = list(range(minint, maxint + 1, 1))

		# Create combinations of all of these values.
		opvalues = list(itertools.product(spreaddata, spreaddata))

		# Filter out values which might cause errors.
		checkedvalues = self.filtertestdata(opvalues, minint, maxint, opname)

		# Sort the data out in order.
		checkedvalues.sort()

		return checkedvalues



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		# These handles lists of floats and ints respectively. 
		# Without using a specialised comparison function it's not 
		# possibly to compare floats properly. These functions allow
		# for better performance on very large data sets than calling
		# assertEqual repeatedly on individual items.
		if 'd' in ('f', 'd'):
			self.addTypeEqualityFunc(list, self.FloatListassertEqual)
		else:
			self.addTypeEqualityFunc(list, self.IntListassertEqual)


		# For operations that support SIMD, this is intended to allow 
		# selecting data sets that fit evenly in the SIMD register width,
		# and also data sets that don't, and so require the non-SIMD
		# clean-up code to be exercised.
		# Since SIMD registers can be 256 bits wide (although not all
		# platforms, we want at least that much data for byte arrays.
		self.simdincr = 256 // 8
		if 'odd' == 'even':
			self.testdatasize = self.simdincr * 4
		if 'odd' == 'odd':
			self.testdatasize = (self.simdincr * 4) - 1


		# For floating point values limit the test values to within
		# the range of precision so that we don't create artificial 
		# test errors due to problems related to numerical resolution.
		if 'd' == 'f':
			minval = arrayfunc.arraylimits.h_min
			maxval = arrayfunc.arraylimits.h_max
		elif 'd' == 'd':
			minval = arrayfunc.arraylimits.i_min
			maxval = arrayfunc.arraylimits.i_max
		else:
			minval = arrayfunc.arraylimits.d_min
			maxval = arrayfunc.arraylimits.d_max


		# Generate the test data for this set of tests.
		tdata = self.gendata_special(minval, maxval, 'mod')

		# If floating point, convert the data to the correct type.
		if 'd' in ('f', 'd'):
			testdata = [(float(x), float(y)) for x,y in tdata]
		else:
			testdata = tdata


		# And separate the data pairs. 
		self.datax = [x for x,y in testdata]
		self.datay = [y for x,y in testdata]



	########################################################
	def test_mod_check_test_data(self):
		"""Test mod to ensure we have valid data present - Array code d.
		"""
		# Make sure we don't have any empty or trivial length data sets.
		# This test exists purely to ensure that the generated and filtered
		# data in setUp is actually present and we don't have any empty
		# data sets after we have pruned them. This condition should not
		# arise unless the test has been edited carelessly.

		self.assertTrue(len(self.datax) >= self.simdincr)
		self.assertTrue(len(self.datay) >= self.simdincr)



	########################################################
	def test_mod_basic_array_num_none_a1(self):
		"""Test mod as *array-num-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a2(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a3(self):
		"""Test mod as *array-num-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_num_none_a4(self):
		"""Test mod as *array-num-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(data1, testvaly, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_array_num_array_b1(self):
		"""Test mod as *array-num-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b2(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b3(self):
		"""Test mod as *array-num-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_num_array_b4(self):
		"""Test mod as *array-num-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvalx] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(data1, testvaly, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_num_array_none_c1(self):
		"""Test mod as *num-array-none* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c2(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c3(self):
		"""Test mod as *num-array-none* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_num_array_none_c4(self):
		"""Test mod as *num-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(data1)[limited:]

				arrayfunc.mod(testvalx, data1, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(data1), expected)



	########################################################
	def test_mod_basic_num_array_array_d1(self):
		"""Test mod as *num-array-array* for basic function - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d2(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				# Only need to calculate one value as they are all the same.
				expected = [operator.mod(testvalx, testvaly)]  * len(data1)

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d3(self):
		"""Test mod as *num-array-array* for basic function with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_num_array_array_d4(self):
		"""Test mod as *num-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		for testvalx, testvaly in zip(self.datax, self.datay):
			with self.subTest(msg='Failed with parameter', testval = (testvalx, testvaly)):

				data1 = array.array('d', [testvaly] * self.testdatasize)
				dataout = array.array('d', [0]*len(data1))

				limited = len(data1) // 2

				# Only need to calculate one value as they are all the same.
				pydataout = [operator.mod(testvalx, testvaly)]  * len(data1)
				expected = pydataout[0:limited] + list(dataout)[limited:]

				arrayfunc.mod(testvalx, data1, dataout, matherrors=True, maxlen=limited)

				# The behavour of assertEqual is modified by addTypeEqualityFunc.
				self.assertEqual(list(dataout), expected)



	########################################################
	def test_mod_basic_array_array_none_e1(self):
		"""Test mod as *array-array-none* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e2(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e3(self):
		"""Test mod as *array-array-none* for basic function with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_none_e4(self):
		"""Test mod as *array-array-none* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(data1)[limited:]

		arrayfunc.mod(data1, data2, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(data1), expected)


	########################################################
	def test_mod_basic_array_array_array_f1(self):
		"""Test mod as *array-array-array* for basic function - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f2(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		expected = [operator.mod(x, y) for (x, y) in zip(data1, data2)]

		arrayfunc.mod(data1, data2, dataout, matherrors=True)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)


	########################################################
	def test_mod_basic_array_array_array_f3(self):
		"""Test mod as *array-array-array* for basic function with matherrors=True and with array limit - Array code d.
		"""
		data1 = array.array('d', self.datax)
		data2 = array.array('d', self.datay)
		dataout = array.array('d', [0]*len(data1))

		limited = len(data1) // 2

		pydataout = [operator.mod(x, y) for (x, y) in zip(data1, data2)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.mod(data1, data2, dataout, matherrors=True, maxlen=limited)

		# The behavour of assertEqual is modified by addTypeEqualityFunc.
		self.assertEqual(list(dataout), expected)



##############################################################################



##############################################################################
class mod_param_errors_d(unittest.TestCase):
	"""Test mod for invalid array and numeric parameters.
	param_invalid_template
	"""


	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.testarray1 = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.testarray2 = array.array('d', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.testarray1)])

		arraysize = len(self.testarray1)

		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))

		# Create some data array equivalents with an incompatible type.
		self.badarray1 = array.array('i', [int(x) for x in self.testarray1])
		self.badarray2 = array.array('i', [int(x) for x in self.testarray2])

		self.baddataout = array.array('i', [int(x) for x in self.dataout])


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for invalid type of array - Array code d.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue)


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for invalid type of number - Array code d.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue)

				testarray1 = copy.copy(self.testarray1)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, badvalue)



	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for invalid type of array - Array code d.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badarray1, testvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for invalid type of number - Array code d.
		"""
		for testvalue, badvalue in zip(self.testarray2, self.badarray2):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				badarray1 = copy.copy(self.badarray1)

				# This version is expected to pass.
				arrayfunc.mod(self.testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(self.testarray1, badvalue, self.dataout)


	########################################################
	def test_mod_array_num_array_b3(self):
		"""Test mod as *array-num-array* for invalid type of output array - Array code d.
		"""
		for testvalue in self.testarray2:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray1 = copy.copy(self.testarray1)

				# This version is expected to pass.
				arrayfunc.mod(testarray1, testvalue, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testarray1, testvalue, self.baddataout)



	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for invalid type of array - Array code d.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)
				badarray2 = copy.copy(self.badarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, badarray2)


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for invalid type of number - Array code d.
		"""
		for testvalue, badvalue in zip(self.testarray1, self.badarray1):
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# Copy the array so we don't change the original data.
				testarray2 = copy.copy(self.testarray2)

				# This version is expected to pass.
				arrayfunc.mod(testvalue, testarray2)

				testarray2 = copy.copy(self.testarray2)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(badvalue, testarray2)



	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for invalid type of array - Array code d.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for invalid type of number - Array code d.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.badarray2, self.dataout)


	########################################################
	def test_mod_num_array_array_d3(self):
		"""Test mod as *num-array-array* for invalid type of output array - Array code d.
		"""
		for testvalue in self.testarray1:
			with self.subTest(msg='Failed with parameter', testvalue = testvalue):

				# This version is expected to pass.
				arrayfunc.mod(testvalue, self.testarray2, self.dataout)

				# This is the actual test.
				with self.assertRaises(TypeError):
					arrayfunc.mod(testvalue, self.testarray2, self.baddataout)



	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code d.
		"""
		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This version is expected to pass.
		arrayfunc.mod(testarray1, self.testarray2)

		# Copy the array so we don't change the original data.
		testarray1 = copy.copy(self.testarray1)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(testarray1, self.badarray2)


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for invalid type of array - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2)



	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.badarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for invalid type of array - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.badarray1, self.testarray2, self.dataout)


	########################################################
	def test_mod_array_array_array_f3(self):
		"""Test mod as *array-array-array* for invalid type of output array - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.testarray1, self.testarray2, self.dataout)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.testarray1, self.testarray2, self.baddataout)


	########################################################
	def test_mod_no_params_g1(self):
		"""Test mod with no parameters - Array code d.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.mod()



##############################################################################



##############################################################################
class mod_opt_param_errors_d(unittest.TestCase):
	"""Test mod for invalid errors flag and maxlen parameters.
	param_invalid_opt_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""

		self.inparray1a = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.inparray1b = copy.copy(self.inparray1a)
		self.inparray2a = array.array('d', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.inparray1a)])
		self.inparray2b = copy.copy(self.inparray2a)

		arraysize = len(self.inparray1a)

		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))

		self.testmaxlen = len(self.inparray1a) // 2


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for matherrors='a' - Array code d.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, matherrors='a')


	########################################################
	def test_mod_array_num_none_a2(self):
		"""Test mod as *array-num-none* for maxlen='a' - Array code d.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, maxlen='a')


	########################################################
	def test_mod_array_num_array_b1(self):
		"""Test mod as *array-num-array* for matherrors='a' - Array code d.
		"""
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_num_array_b2(self):
		"""Test mod as *array-num-array* for maxlen='a' - Array code d.
		"""
		# Copy the array so we don't change the original data.
		inpvalue = self.inparray2a[0]

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, inpvalue, self.dataout, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, inpvalue, self.dataout, maxlen='a')


	########################################################
	def test_mod_num_array_none_c1(self):
		"""Test mod as *num-array-none* for matherrors='a' - Array code d.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, matherrors=True)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_num_array_none_c2(self):
		"""Test mod as *num-array-none* for maxlen='a' - Array code d.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, maxlen=self.testmaxlen)


		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_num_array_array_d1(self):
		"""Test mod as *num-array-array* for matherrors='a' - Array code d.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_num_array_array_d2(self):
		"""Test mod as *num-array-array* for maxlen='a' - Array code d.
		"""
		inpvalue = self.inparray1a[0]

		# This version is expected to pass.
		arrayfunc.mod(inpvalue, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(inpvalue, self.inparray2b, self.dataout, maxlen='a')


	########################################################
	def test_mod_array_array_none_e1(self):
		"""Test mod as *array-array-none* for matherrors='a' - Array code d.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, matherrors='a')


	########################################################
	def test_mod_array_array_none_e2(self):
		"""Test mod as *array-array-none* for maxlen='a' - Array code d.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, maxlen='a')


	########################################################
	def test_mod_array_array_array_f1(self):
		"""Test mod as *array-array-array* for matherrors='a' - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, matherrors=True)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, matherrors='a')


	########################################################
	def test_mod_array_array_array_f2(self):
		"""Test mod as *array-array-array* for maxlen='a' - Array code d.
		"""

		# This version is expected to pass.
		arrayfunc.mod(self.inparray1a, self.inparray2a, self.dataout, maxlen=self.testmaxlen)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.mod(self.inparray1b, self.inparray2b, self.dataout, maxlen='a')



##############################################################################



##############################################################################
class overflow_signed_divzero_d(unittest.TestCase):
	"""Test mod for value divide by zero.
	param_overflow_mod_divzero_template
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		arraysize = 200
		self.MaxLimit = arrayfunc.arraylimits.d_max
		self.MinLimit = arrayfunc.arraylimits.d_min


		self.inparray1amax = array.array('d', [self.MaxLimit] * arraysize)
		self.inparray1bmax = copy.copy(self.inparray1amax)

		self.zero1array = array.array('d', [0.0] * arraysize)
		self.plus1array = array.array('d', [1.0] * arraysize)

		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))


	########################################################
	def test_mod_array_num_none_a1(self):
		"""Test mod as *array-num-none* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1.0)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0.0)


	########################################################
	def test_mod_array_num_array_a2(self):
		"""Test mod as *array-num-array* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, 1.0, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, 0.0, self.dataout)


	########################################################
	def test_mod_num_array_none_a3(self):
		"""Test mod as *num-array-none* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array)


	########################################################
	def test_mod_num_array_array_a4(self):
		"""Test mod as *num-array-array* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.MaxLimit, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.MaxLimit, self.zero1array, self.dataout)


	########################################################
	def test_mod_array_array_none_a5(self):
		"""Test mod as *array-array-none* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array)


	########################################################
	def test_mod_array_array_array_a6(self):
		"""Test mod as *array-array-array* for max value % 0.0 - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.inparray1amax, self.plus1array, self.dataout)

		# This is the actual test.
		with self.assertRaises(ZeroDivisionError):
			arrayfunc.mod(self.inparray1bmax, self.zero1array, self.dataout)



##############################################################################



##############################################################################
class mod_NaN_errors_d(unittest.TestCase):
	"""Test mod for basic general function operation using parameter nan.
	nan_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('d', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('d', [float('nan')] * arraysize)



	########################################################
	def test_mod_NaN_array_num_none_a1(self):
		"""Test mod as *array-num-none* for nan - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_NaN_array_num_none_a2(self):
		"""Test mod as *array-num-none* for nan with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_num_array_b1(self):
		"""Test mod as *array-num-array* for nan - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_NaN_array_num_array_b2(self):
		"""Test mod as *array-num-array* for nan with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_num_array_none_c1(self):
		"""Test mod as *num-array-none* for nan - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_NaN_num_array_none_c2(self):
		"""Test mod as *num-array-none* for nan with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				expected = [testval % x for x in self.errordata]

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_num_array_array_d1(self):
		"""Test mod as *num-array-array* for nan - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_NaN_num_array_array_d2(self):
		"""Test mod as *num-array-array* for nan with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [testval % x for x in self.errordata]

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_array_none_e1(self):
		"""Test mod as *array-array-none* for nan - Array code d.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_NaN_array_array_none_e2(self):
		"""Test mod as *array-array-none* for nan with error check off - Array code d.
		"""
		expected = [y % x for x,y in zip(self.errordata, self.dataok1)]

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_NaN_array_array_array_f1(self):
		"""Test mod as *array-array-array* for nan - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_NaN_array_array_array_f2(self):
		"""Test mod as *array-array-array* for nan with error check off - Array code d.
		"""
		expected = [y % x for x,y in zip(self.errordata, self.dataok1)]

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################



##############################################################################
class mod_inf_errors_d(unittest.TestCase):
	"""Test mod for basic general function operation using parameter inf.
	inf_mod_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('d', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('d', [float('inf')] * arraysize)



	########################################################
	def test_mod_inf_array_num_none_a1(self):
		"""Test mod as *array-num-none* for inf - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_inf_array_num_none_a2(self):
		"""Test mod as *array-num-none* for inf with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_num_array_b1(self):
		"""Test mod as *array-num-array* for inf - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_inf_array_num_array_b2(self):
		"""Test mod as *array-num-array* for inf with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_num_array_none_c1(self):
		"""Test mod as *num-array-none* for inf - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_inf_num_array_none_c2(self):
		"""Test mod as *num-array-none* for inf with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_num_array_array_d1(self):
		"""Test mod as *num-array-array* for inf - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_inf_num_array_array_d2(self):
		"""Test mod as *num-array-array* for inf with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_array_none_e1(self):
		"""Test mod as *array-array-none* for inf - Array code d.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_inf_array_array_none_e2(self):
		"""Test mod as *array-array-none* for inf with error check off - Array code d.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_inf_array_array_array_f1(self):
		"""Test mod as *array-array-array* for inf - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_inf_array_array_array_f2(self):
		"""Test mod as *array-array-array* for inf with error check off - Array code d.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################



##############################################################################
class mod_ninf_errors_d(unittest.TestCase):
	"""Test mod for basic general function operation using parameter -inf.
	inf_mod_data_error_template
	"""


	##############################################################################
	def FloatassertEqual(self, dataoutitem, expecteditem, msg=None):
		"""This function is patched into assertEqual to allow testing for 
		the floating point special values NaN, Inf, and -Inf.
		"""
		# NaN cannot be compared using normal means.
		if math.isnan(dataoutitem) and math.isnan(expecteditem):
			pass
		# Anything else can be compared normally.
		else:
			if not math.isclose(expecteditem, dataoutitem, rel_tol=0.01, abs_tol=0.0):
				raise self.failureException('%0.3f != %0.3f' % (expecteditem, dataoutitem))



	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# This is active for float numbers only. 
		self.addTypeEqualityFunc(float, self.FloatassertEqual)

		self.dataok1 = array.array('d', [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0])
		self.dataok2 = array.array('d', [x for (x,y) in zip(itertools.cycle([-2.0,-1.0,1.0,2.0]), self.dataok1)])

		arraysize = len(self.dataok1)


		self.dataout = array.array('d', itertools.repeat(0.0, arraysize))

		self.errordata = array.array('d', [float('-inf')] * arraysize)



	########################################################
	def test_mod_ninf_array_num_none_a1(self):
		"""Test mod as *array-num-none* for -inf - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval)


	########################################################
	def test_mod_ninf_array_num_none_a2(self):
		"""Test mod as *array-num-none* for -inf with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(errordata, testval, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_num_array_b1(self):
		"""Test mod as *array-num-array* for -inf - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok1 = copy.copy(self.dataok1)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(dataok1, testval, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(errordata, testval, self.dataout)


	########################################################
	def test_mod_ninf_array_num_array_b2(self):
		"""Test mod as *array-num-array* for -inf with error check off - Array code d.
		"""
		for testval in [-2.0,-1.0,1.0,2.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				expected = [x % testval for x in self.errordata]

				arrayfunc.mod(self.errordata, testval, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_num_array_none_c1(self):
		"""Test mod as *num-array-none* for -inf - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				dataok2 = copy.copy(self.dataok2)
				errordata = copy.copy(self.errordata)

				# This version is expected to pass.
				arrayfunc.mod(testval, dataok2)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, errordata)


	########################################################
	def test_mod_ninf_num_array_none_c2(self):
		"""Test mod as *num-array-none* for -inf with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# Copy the array so we don't change the original data.
				errordata = copy.copy(self.errordata)
				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, errordata, matherrors=True)

				for dataoutitem, expecteditem in zip(errordata, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_num_array_array_d1(self):
		"""Test mod as *num-array-array* for -inf - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This version is expected to pass.
				arrayfunc.mod(testval, self.dataok2, self.dataout)

				# This is the actual test.
				with self.assertRaises(ArithmeticError):
					arrayfunc.mod(testval, self.errordata, self.dataout)


	########################################################
	def test_mod_ninf_num_array_array_d2(self):
		"""Test mod as *num-array-array* for -inf with error check off - Array code d.
		"""
		for testval in [100.0,101.0,102.0,103.0,104.0,105.0,106.0,107.0,108.0,109.0]:
			with self.subTest(msg='Failed with parameter', testval = testval):

				# This test results in "nan".
				expected = [math.nan] * len(self.errordata)

				arrayfunc.mod(testval, self.errordata, self.dataout, matherrors=True)

				for dataoutitem, expecteditem in zip(self.dataout, expected):
					# The behavour of assertEqual is modified by addTypeEqualityFunc.
					self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_array_none_e1(self):
		"""Test mod as *array-array-none* for -inf - Array code d.
		"""
		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)
		dataok2 = copy.copy(self.dataok2)

		# This version is expected to pass.
		arrayfunc.mod(dataok1, dataok2)

		# Copy the array so we don't change the original data.
		dataok1 = copy.copy(self.dataok1)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(dataok1, self.errordata)


	########################################################
	def test_mod_ninf_array_array_none_e2(self):
		"""Test mod as *array-array-none* for -inf with error check off - Array code d.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataok1, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)



	########################################################
	def test_mod_ninf_array_array_array_f1(self):
		"""Test mod as *array-array-array* for -inf - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.mod(self.dataok1, self.dataok2, self.dataout)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.mod(self.dataok1, self.errordata, self.dataout)


	########################################################
	def test_mod_ninf_array_array_array_f2(self):
		"""Test mod as *array-array-array* for -inf with error check off - Array code d.
		"""
		# This test results in "nan".
		expected = [math.nan] * len(self.errordata)

		arrayfunc.mod(self.dataok1, self.errordata, self.dataout, matherrors=True)

		for dataoutitem, expecteditem in zip(self.dataout, expected):
			# The behavour of assertEqual is modified by addTypeEqualityFunc.
			self.assertEqual(dataoutitem, expecteditem)


##############################################################################


##############################################################################
if __name__ == '__main__':

	# Check to see if the log file option has been selected. This is an option
	# which we have added in order to decide where to output the results.
	if '-l' in sys.argv:
		# Remove the option from the argument list so that "unittest" does 
		# not complain about unknown options.
		sys.argv.remove('-l')

		with open('af_unittest.txt', 'a') as f:
			f.write('\n\n')
			f.write('mod\n\n')
			trun = unittest.TextTestRunner(f)
			unittest.main(testRunner=trun)
	else:
		unittest.main()

##############################################################################
