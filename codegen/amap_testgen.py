#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Purpose:  Generate the unit tests for amap and amapi.
# Language: Python 3.4
# Date:     27-May-2014
#
###############################################################################
#
#   Copyright 2014 - 2015    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################


# ==============================================================================

import itertools
import codegen_common

# ==============================================================================

# This is a helper function required for some tests.
InvertPy = '''
##############################################################################
# The maximum values for selected array types.
IPLims = {'B' : arrayfunc.arraylimits.B_max , 'H' : arrayfunc.arraylimits.H_max, 
			'I' : arrayfunc.arraylimits.I_max, 'L' : arrayfunc.arraylimits.L_max, 
			'f' : arrayfunc.arraylimits.f_max, 'd' : arrayfunc.arraylimits.d_max}

# Add 'Q' arrays if this is supported on this platform.
if 'Q' in array.typecodes:
	IPLims['Q'] = arrayfunc.arraylimits.Q_max

def InvertPy(typecode, val):
	"""This allows for the invert operation to handle both signed and 
	unsigned integers.
	"""
	# Python native integers are signed.
	if typecode in ('b', 'h', 'i', 'l', 'q'):
		return ~val
	# Unsigned integers require more work to invert.
	else:
		maxval = IPLims[typecode]
		if val >= 0:
			return maxval - val
		else:
			return maxval + val


##############################################################################
'''

# This is used to insert code to convert the test data to bytes type. 
bytesconverterdata = 'data = bytes(data)'
bytesconverterdataout = 'dataout = bytes(dataout)'

# ==============================================================================

# With some platforms (Windows), the compiler does not support all functions.
# This means we cannot test for them.
PlatformClassSkip = """@unittest.skipIf(platform.python_compiler().startswith('MSC'), 'Skip test if not supported by the platform C compiler.')
"""

# This version is used for individual tests, as opposed to the entire class.
PlatformTestSkip = '\t' + PlatformClassSkip

# ==============================================================================

# The basic class template for testing each array type for operator function.
type_template = '''
##############################################################################
%(skiplonglong)sclass amap_operator_%(typelabel)s(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'

'''



test_template = '''
	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(yparamdata)s)
		%(amapassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amap_ov(self):
		"""Test amap %(opcodename)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(yparamdata)s, disovfl=True)
		%(amapassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amap_lim(self):
		"""Test amap %(opcodename)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(yparamdata)s, maxlen=limited)
		%(amapassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amap_ov_lim(self):
		"""Test amap %(opcodename)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(yparamdata)s, disovfl=True, maxlen=limited)
		%(amapassertoperation)s



	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s

		expected = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(yparamdata)s)
		%(amapiassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amapi_ov(self):
		"""Test amapi %(opcodename)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s

		expected = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(yparamdata)s, disovfl=True)
		%(amapiassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amapi_lim(self):
		"""Test amapi %(opcodename)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(data)[limited:]

		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(yparamdata)s, maxlen=limited)
		%(amapiassertoperation)s


	########################################################
	def test_operator_%(opcodename)s_%(testcount)s_amapi_ov_lim(self):
		"""Test amapi %(opcodename)s with overflow checking disabled and array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(data)[limited:]

		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(yparamdata)s, disovfl=True, maxlen=limited)
		%(amapiassertoperation)s



'''


# This template is for operators which do not use a second parameter.
test_template_noparams = '''
	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyequ)s for x in data]
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout)
		%(amapassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amap_ov(self):
		"""Test amap %(opcodename)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyequ)s for x in data]
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, disovfl=True)
		%(amapassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amap_lim(self):
		"""Test amap %(opcodename)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x in data]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, maxlen=limited)
		%(amapassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amap_ov_lim(self):
		"""Test amap %(opcodename)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x in data]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, disovfl=True, maxlen=limited)
		%(amapassertoperation)s



	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s

		expected = [%(pyequ)s for x in data]
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data)
		%(amapiassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amapi_ov(self):
		"""Test amapi %(opcodename)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s

		expected = [%(pyequ)s for x in data]
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, disovfl=True)
		%(amapiassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amapi_lim(self):
		"""Test amapi %(opcodename)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x in data]
		expected = pydataout[0:limited] + list(data)[limited:]

		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, maxlen=limited)
		%(amapiassertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(opcodename)s_%(testcount)s_amapi_ov_lim(self):
		"""Test amapi %(opcodename)s with overflow checking disabled and array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		limited = len(data) // 2

		pydataout = [%(pyequ)s for x in data]
		expected = pydataout[0:limited] + list(data)[limited:]

		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, disovfl=True, maxlen=limited)
		%(amapiassertoperation)s



'''


# ==============================================================================



# The basic class template for testing each array type for integer overflow.
intoverflow_type_template = '''
##############################################################################
%(skiplonglong)sclass amap_intoverflow_%(typelabel)s(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min


'''


intoverflow_template_stnd = '''
	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(ovfl_param2)s)

	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s

		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(ovfl_param2)s)

'''


intoverflow_template_noovfl = '''
	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_disabled_amap(self):
		"""Test amap integer overflow checking disabled in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(ovfl_param2)s, disovfl=True)

	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_disabled_amapi(self):
		"""Test amapi integer overflow checking disabled in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s

		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(ovfl_param2)s, disovfl=True)

'''


intoverflow_template_noparam = '''
	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout)

	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s

		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data)

'''

# ==============================================================================

intfuncoverflow_template_noparam = '''
	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap integer overflow in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout)

	########################################################
	def test_intoverflow_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi integer overflow in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s

		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data)

'''

# ==============================================================================


# ==============================================================================
# These templates handle whether to do exact compares with integer arrays, or
# approximate compares with floating point compares.

# This bit is not a complete template, but rather is used to complete some of the other templates.
almost_template = """
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)
"""

amap_exact_template = "self.assertEqual(list(dataout), expected)"
amap_almost_template = "for dataoutitem, expecteditem in zip(list(dataout), expected):" + almost_template

amapi_exact_template = "self.assertEqual(list(data), expected)"
amapi_almost_template = "for dataoutitem, expecteditem in zip(list(data), expected):" + almost_template

# ==============================================================================

# The basic class template for testing each array type for floating point overflow.
floatoverflow_type_template = '''
##############################################################################
%(skiplonglong)sclass amap_floatoverflow_%(typelabel)s(unittest.TestCase):
	"""Test for floating point overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min


'''


floatoverflow_template_stnd = '''
	########################################################
	def test_floatoverflow_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		dataout = array.array('%(typecode)s', [0]*10)

		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(ovfl_param2)s)

	########################################################
	def test_floatoverflow_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)

		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(ovfl_param2)s)

'''



floatoverflow_template_noparam = '''
	########################################################
	def test_floatoverflow_%(opcodename)s_%(testcount)s_amap(self):
		"""Test amap floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		dataout = array.array('%(typecode)s', [0]*10)

		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout)

	########################################################
	def test_floatoverflow_%(opcodename)s_%(testcount)s_amapi(self):
		"""Test amapi floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)

		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data)

'''


# ==============================================================================

# The basic class template for testing each floating point library item for math errors.
floaterror_class_template = '''
##############################################################################
%(skiplonglong)sclass amap_floaterror_%(typelabel)s(unittest.TestCase):
	"""Test for floating point overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min


'''

# Math functions which take one parameter.
floaterror_template = '''
	########################################################
%(skipplatform)s	def test_floaterror_%(opcodename)s_amap(self):
		"""Test amap floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', range(%(test_float_err_x)s))
		dataout = array.array('%(typecode)s', [0]*len(data))

		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout)

	########################################################
%(skipplatform)s	def test_floaterror_%(opcodename)s_amapi(self):
		"""Test amapi floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', range(%(test_float_err_x)s))

		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data)

'''



# Math functions which take two parameters.
floaterror_template_2params = '''
	########################################################
	def test_floaterror_%(opcodename)s_amap(self):
		"""Test amap floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_float_err_x)s])
		dataout = array.array('%(typecode)s', [0]*len(data))

		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, data, dataout, %(test_float_err_y)s)

	########################################################
	def test_floaterror_%(opcodename)s_amapi(self):
		"""Test amapi floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_float_err_x)s])

		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, data, %(test_float_err_y)s)

'''

# ==============================================================================


# The basic template for testing parameters.
param_template = '''
##############################################################################
%(skiplonglong)sclass amap_parameter_%(typelabel)s(unittest.TestCase):
	"""Test for correct parameters.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('%(typecode)s', [%(typeconvert)s(10)]*10)
		self.param = %(typeconvert)s(12)
		self.dataout = array.array('%(typecode)s', [%(typeconvert)s(0)]*10)
		self.dataempty = array.array('%(typecode)s')
		self.datashort = array.array('%(typecode)s', [%(typeconvert)s(3)]*5)


		# For bytes types, we need a non-array data type.
		if '%(typelabel)s' == 'bytes':
			self.data = bytes(self.data)
			self.dataout = bytes(self.dataout)
			self.dataempty = bytes(self.dataempty)
			self.datashort = bytes(self.datashort)


	########################################################
	def test_param_01_amap_no_params(self):
		"""Test amap exception when no parameters passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap()

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map()

	########################################################
	def test_param_02_amapi_no_params(self):
		"""Test amapi exception when no parameters passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi()

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map()

	########################################################
	def test_param_02_amap_one_params(self):
		"""Test amap exception when one parameter passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x)

	########################################################
	def test_param_03_amapi_one_params(self):
		"""Test amapi  exception when one parameter passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x)


	########################################################
	def test_param_04_amap_two_params(self):
		"""Test amap exception when two parameters are passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x)

	########################################################
	def test_param_05_amapi_two_params(self):
		"""Test amapi  exception when two parameters are passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.data)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x)


	########################################################
	def test_param_06_amap_three_params(self):
		"""Test amap exception when three parameters are passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataout)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x)


	########################################################
	def test_param_07_amap_seven_params(self):
		"""Test amap exception when seven parameters are passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataout, self.param, False, 2, 2)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], 2)


	########################################################
	def test_param_08_amapi_six_params(self):
		"""Test amapi  exception when six parameters are passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.data, self.param, False, 2, 2)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], 2)


	########################################################
	def test_param_09_amap_invalid_keyword_params(self):
		"""Test amap exception with invalid keyword parameters passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataout, self.param, xx=2)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], xx=2)

	########################################################
	def test_param_10_amapi_invalid_keyword_params(self):
		"""Test amapi exception with invalid keyword parameters passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.data, self.param, xx=2)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], xx=2)


	########################################################
	def test_param_11_amap_invalid_keyword_param_type(self):
		"""Test amap exception with invalid keyword parameter type passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataout, self.param, maxlen='x')

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], maxlen='x')


	########################################################
	def test_param_12_amapi_invalid_keyword_param_type(self):
		"""Test amapi exception with invalid keyword parameter type passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.data, self.param, maxlen='x')

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, [1,2,3], maxlen='x')


	########################################################
	def test_param_13_amap_invalid_opcode_param_value(self):
		"""Test amap exception with invalid opcode parameter value passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ValueError):
			arrayfunc.amap(-1, self.data, self.dataout, self.param)


	########################################################
	def test_param_14_amapi_invalid_opcode_param_value(self):
		"""Test amapi exception with invalid opcode parameter value passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ValueError):
			arrayfunc.amapi(-1, self.data, self.param)


	########################################################
	def test_param_15_amap_invalid_opcode_param_type(self):
		"""Test amap exception with invalid opcode parameter type passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap('a', self.data, self.dataout, self.param)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = list(map('a', [1,2,3]))


	########################################################
	def test_param_16_amapi_invalid_opcode_param_type(self):
		"""Test amapi exception with invalid opcode parameter type passed  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi('a', self.data, self.param)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = list(map('a', [1,2,3]))


	########################################################
	def test_param_17_amap_invalid_first_array_param_type(self):
		"""Test amap exception with invalid first array parameter type  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, 99, self.dataout, self.param)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, 99)

	########################################################
	def test_param_18_amap_invalid_second_array_param_type(self):
		"""Test amap exception with invalid second array parameter type  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, 99, self.param)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, 99)

	########################################################
	def test_param_19_amap_invalid_fourth_value_param_type(self):
		"""Test amap exception with invalid fourth value parameter type  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataout, 'a')

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, 99)


	########################################################
	def test_param_20_amapi_invalid_first_array_param_type(self):
		"""Test amapi exception with invalid first array parameter type  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, 99, self.param)

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, 99)

	########################################################
	def test_param_21_amapi_invalid_second_value_param_type(self):
		"""Test amapi exception with invalid second value parameter type  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.data, 'a')

		# Check that the exception raised corresponds to the native Python behaviour.
		with self.assertRaises(TypeError):
			result = map(lambda x: x, 99)



	########################################################
	def test_param_22_amap_invalid_first_array_param_length(self):
		"""Test amap exception with invalid first array parameter length  - Array code %(typelabel)s.
		"""
		with self.assertRaises(IndexError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataempty, self.dataout, self.param)

	########################################################
	def test_param_23_amap_invalid_second_array_param_length(self):
		"""Test amap exception with invalid second array parameter length  - Array code %(typelabel)s.
		"""
		with self.assertRaises(IndexError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.dataempty, self.param)


	########################################################
	def test_param_24_amapi_invalid_first_array_param_length(self):
		"""Test amapi exception with invalid first array parameter length  - Array code %(typelabel)s.
		"""
		with self.assertRaises(IndexError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataempty, self.param)




	########################################################
	def test_param_25_amap_unequal_first_array_param_length(self):
		"""Test amap exception with unequal first array parameter length  - Array code %(typelabel)s.
		"""
		with self.assertRaises(IndexError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datashort, self.dataout, self.param)


	########################################################
	def test_param_26_amap_unequal_second_array_param_length(self):
		"""Test amap exception with unequal second array parameter length  - Array code %(typelabel)s.
		"""
		with self.assertRaises(IndexError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.data, self.datashort, self.param)



##############################################################################

'''

# ==============================================================================


# The template used to generate the tests for nan, inf, -inf in parameters.
nan_param_template = '''
##############################################################################
%(skipplatform)sclass amap_nan_param_%(opcodename)s_%(typelabel)s(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in parameters.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('%(typecode)s', [100.0] * 10)
		self.dataok = array.array('%(typecode)s', [100.0] * 10)
		self.dataok2 = array.array('%(typecode)s', [100.0] * 10)
		self.dataout = array.array('%(typecode)s', itertools.repeat(0.0, 10))


	########################################################
	def test_nan_%(opcodename)s_01(self):
		"""Test amap for param of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, 1.0)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, float('nan'))


	########################################################
	def test_nan_%(opcodename)s_02(self):
		"""Test amapi for param of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, 1.0)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, float('nan'))


	########################################################
	def test_nan_%(opcodename)s_03(self):
		"""Test amap for param of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, float('inf'))


	########################################################
	def test_nan_%(opcodename)s_04(self):
		"""Test amapi for param of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, float('inf'))


	########################################################
	def test_nan_%(opcodename)s_05(self):
		"""Test amap for param of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(OverflowError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, float('-inf'))


	########################################################
	def test_nan_%(opcodename)s_06(self):
		"""Test amapi for param of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(OverflowError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, float('-inf'))


	########################################################
	def test_nan_%(opcodename)s_07(self):
		"""Test amap for lim of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, 1.0, maxlen=len(self.data) // 2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, maxlen=float('nan'))


	########################################################
	def test_nan_%(opcodename)s_08(self):
		"""Test amapi for lim of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, 1.0, maxlen=len(self.data) // 2)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, maxlen=float('nan'))


	########################################################
	def test_nan_%(opcodename)s_09(self):
		"""Test amap for lim of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, maxlen=float('inf'))


	########################################################
	def test_nan_%(opcodename)s_10(self):
		"""Test amapi for lim of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, maxlen=float('inf'))


	########################################################
	def test_nan_%(opcodename)s_11(self):
		"""Test amap for lim of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, maxlen=float('-inf'))


	########################################################
	def test_nan_%(opcodename)s_12(self):
		"""Test amapi for lim of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, maxlen=float('-inf'))


	########################################################
	def test_nan_%(opcodename)s_13(self):
		"""Test amap for ov of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, 1.0, disovfl=True)
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok2, self.dataout, 1.0, disovfl=False)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, disovfl=float('nan'))


	########################################################
	def test_nan_%(opcodename)s_14(self):
		"""Test amapi for ov of nan  - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, 1.0, disovfl=True)
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok2, 1.0, disovfl=False)

		# This is the actual test.
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, disovfl=float('nan'))


	########################################################
	def test_nan_%(opcodename)s_15(self):
		"""Test amap for ov of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, disovfl=float('inf'))


	########################################################
	def test_nan_%(opcodename)s_16(self):
		"""Test amapi for ov of inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, disovfl=float('inf'))


	########################################################
	def test_nan_%(opcodename)s_17(self):
		"""Test amap for ov of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data, self.dataout, 1.0, disovfl=float('-inf'))


	########################################################
	def test_nan_%(opcodename)s_18(self):
		"""Test amapi for ov of -inf  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data, 1.0, disovfl=float('-inf'))


##############################################################################
'''

# ==============================================================================

# The template used to start off the tests for nan, inf, -inf in data arrays.
nan_data_header_template = '''
##############################################################################
%(skipplatform)sclass amap_nan_data_%(opcodename)s_%(seq)s_%(typelabel)s(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('%(typecode)s', [%(xparamdata)s] * 10)
		self.dataok = array.array('%(typecode)s', [%(xparamdata)s] * 10)

		self.dataout = array.array('%(typecode)s', itertools.repeat(0.0, 10))

		self.datainf = array.array('%(typecode)s', [float('inf')] * 10)
		self.datanan = array.array('%(typecode)s', [float('nan')] * 10)
		self.dataninf = array.array('%(typecode)s', [float('-inf')] * 10)

'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected.
nan_data_error_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, %(yparamdata)s)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, %(yparamdata)s)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are not expected.
nan_data_noerror_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking on and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking on and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# for floordiv_r with inf or -inf. This is a special case due to the results of 
# dividing by infinity.
nan_data_floordiv_r_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking on and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking on and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for pow since raising
# any value to 0 will always return 1.
nan_data_powerror_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
			((('%(opcodename)s' in ('af_pow', 'math_pow')) and (%(yparamdata)s == 0.0)) or
				(('%(opcodename)s' in ('af_pow_r', 'math_pow_r')) and (%(yparamdata)s == 1.0)))):
				expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, %(yparamdata)s)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)
		else:
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
			((('%(opcodename)s' in ('af_pow', 'math_pow')) and (%(yparamdata)s == 0.0)) or
				(('%(opcodename)s' in ('af_pow_r', 'math_pow_r')) and (%(yparamdata)s == 1.0)))):
				expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, %(yparamdata)s)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)
		else:
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
			((('%(opcodename)s' in ('af_pow', 'math_pow')) and (%(yparamdata)s == 0.0)) or
				(('%(opcodename)s' in ('af_pow_r', 'math_pow_r')) and (%(yparamdata)s == 1.0)))):
				expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
			((('%(opcodename)s' in ('af_pow', 'math_pow')) and (%(yparamdata)s == 0.0)) or
				(('%(opcodename)s' in ('af_pow_r', 'math_pow_r')) and (%(yparamdata)s == 1.0)))):
				expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for fmod, and fmod_r.
nan_data_fmoderror_param_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, %(yparamdata)s)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)
		else:
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.dataok, %(yparamdata)s)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)
		else:
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for af_mod, and af_mod_r.
nan_data_af_mod_error_param_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.dataok, self.dataout, %(yparamdata)s)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.data%(testarray)s)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and a second parameter is present.
nan_data_error_param_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, %(yparamdata)s, disovfl=True)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, %(yparamdata)s, disovfl=True)


'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and no second parameter is present.
nan_data_error_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, disovfl=True)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, disovfl=True)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are not expected and no second parameter is present. 
nan_data_noerror_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''




# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and no second parameter is present. When overflow
# checking is turned off, the results are checked.
nan_data_errorchecked_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.data%(testarray)s), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for isnan and isinf only
nan_data_isnanisinftest_template = '''
	########################################################
	def test_%(testarray)s_%(opcodename)s_amap(self):
		"""Test amap for %(opcodename)s with %(testlabel)s - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [float(%(pyoperator)s(x)) for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_%(testarray)s_%(opcodename)s_amapi(self):
		"""Test amapi for %(opcodename)s with %(testlabel)s - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [float(%(pyoperator)s(x)) for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s)

		self.assertEqual(list(self.data%(testarray)s), expected)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amap(self):
		"""Test amap for %(opcodename)s with overflow checking off with %(testlabel)s - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [float(%(pyoperator)s(x)) for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_%(testarray)s_%(opcodename)s_ov_amapi(self):
		"""Test amapi for %(opcodename)s with overflow checking off with %(testlabel)s - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [float(%(pyoperator)s(x)) for x in self.data%(testarray)s]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.%(opcodename)s, self.data%(testarray)s, disovfl=True)

		self.assertEqual(list(self.data%(testarray)s), expected)


'''


# ==============================================================================


classend = """##############################################################################
"""

endtemplate = """
##############################################################################
if __name__ == '__main__':
    unittest.main()

##############################################################################
"""


# ==============================================================================

# These are all the test code templates. 
test_templates = {'test_template' : test_template,
	'test_template_noparams' : test_template_noparams,
	'intoverflow_template_stnd' : intoverflow_template_stnd,
	'intoverflow_template_noovfl' : intoverflow_template_noovfl,
	'intoverflow_template_noparam' : intoverflow_template_noparam,
	'intfuncoverflow_template_noparam' : intfuncoverflow_template_noparam,
	'floatoverflow_template_stnd' : floatoverflow_template_stnd,
	'floatoverflow_template_noparam' : floatoverflow_template_noparam,
	'floaterror_template' : floaterror_template,
	'floaterror_template_2params' : floaterror_template_2params,
	'param_template' : param_template,
	'nan_data_error_template' : nan_data_error_template,
	'nan_data_noerror_template' : nan_data_noerror_template,
	'nan_data_error_noparam_template' : nan_data_error_noparam_template,
	'nan_data_isnanisinftest_template' : nan_data_isnanisinftest_template,
	'nan_data_errorchecked_noparam_template' : nan_data_errorchecked_noparam_template,
	'nan_data_noerror_noparam_template' : nan_data_noerror_noparam_template,
	'nan_data_powerror_template' : nan_data_powerror_template,
	'nan_data_fmoderror_param_template' : nan_data_fmoderror_param_template,
	'nan_data_af_mod_error_param_template' : nan_data_af_mod_error_param_template,
	'nan_data_error_param_template' : nan_data_error_param_template,
	'nan_data_floordiv_r_template' : nan_data_floordiv_r_template,


}



# ==============================================================================

# Read the operator and function definition data.
csvdata = codegen_common.ReadCSVData()


# ==============================================================================
# Test basic operations.


def makeoptests(csvdata, arraycode, arraylabel):
	"""Make a complete set of tests for all array types.
	"""

	# The type of unit test assert we use for testing the results depends on
	# whether we are comparing floating point or integer values.
	if arraycode in codegen_common.signedint:
		opdata = [x for x in csvdata if x['test_op_templ_isigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.unsignedint:
		opdata = [x for x in csvdata if x['test_op_templ_iunsigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.floatarrays:
		opdata = [x for x in csvdata if x['test_op_templ_float'] != '']
		typeconvert = 'float'

	else:
		print('Unknow array code %s' % arraycode)
		typecode = arraycode


	# Create the records.
	testresults = []
	for rec in opdata:
		# Avoid changing the original record.
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraylabel

		testrec.update(rec)

		if arraycode in codegen_common.signedint:
			test_op_x = rec['test_op_x_isigned']
			test_op_y = rec['test_op_y_isigned']
			testtemplate = test_templates[rec['test_op_templ_isigned']]
			testrec['amapassertoperation'] = amap_exact_template
			testrec['amapiassertoperation'] = amapi_exact_template

		elif arraycode in codegen_common.unsignedint:
			test_op_x = rec['test_op_x_iunsigned']
			test_op_y = rec['test_op_y_iunsigned']
			testtemplate = test_templates[rec['test_op_templ_iunsigned']]
			testrec['amapassertoperation'] = amap_exact_template
			testrec['amapiassertoperation'] = amapi_exact_template

		elif arraycode in codegen_common.floatarrays:
			test_op_x = rec['test_op_x_float']
			test_op_y = rec['test_op_y_float']
			testtemplate = test_templates[rec['test_op_templ_float']]
			testrec['amapassertoperation'] = amap_almost_template
			testrec['amapiassertoperation'] = amapi_almost_template

		else:
			print('Unknow array code %s' % arraycode)


		pyop = rec['py_equation'] % {'op' : rec['pyoperator'], 'X' : 'data[x]', 'Y' : 'param1', 'typeconvert' : typeconvert}
		testrec['pyequ'] = pyop
		testrec['test_op_x'] = test_op_x

		# Split the individual test values out.
		yparamdata = test_op_y.split(',')


		# Add in the byte converter for bytes data.
		if arraylabel == 'bytes':
			testrec['bytesconverterdata'] = bytesconverterdata
			testrec['bytesconverterdataout'] = bytesconverterdataout
		else:
			testrec['bytesconverterdata'] = ''
			testrec['bytesconverterdataout'] = ''


		# Add in the test skip if this instruction is not supported on all platforms.
		if rec['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformTestSkip
		else:
			testrec['skipplatform'] = ''


		# Generate a test for each test data element.
		testcount = 0
		for testval in yparamdata:
			testcount += 1
			testrec['testcount'] = testcount
			testrec['yparamdata'] = testval
			testresults.append(testtemplate % testrec)


	return ''.join(testresults)



# ==============================================================================

# ==============================================================================

def makeoverflowtestset(csvdata, arraycode, arraylabel):
	"""Make a complete set of tests for overflow tests.
	"""
	# The type of unit test assert we use for testing the results depends on
	# whether we are comparing floating point or integer values.
	if arraycode in codegen_common.signedint:
		opdata = [x for x in csvdata if x['test_ovfl_templ_isigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.unsignedint:
		opdata = [x for x in csvdata if x['test_ovfl_templ_iunsigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.floatarrays:
		opdata = [x for x in csvdata if x['test_ovfl_templ_float'] != '']
		typeconvert = 'float'

	else:
		print('Unknow array code %s' % arraycode)
		typecode = arraycode


	# Create the records.
	testresults = []
	for rec in opdata:
		# Avoid changing the original record.
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraylabel

		testrec.update(rec)

		if arraycode in codegen_common.signedint:
			test_op_x = rec['test_ovfl_x_isigned']
			test_op_y = rec['test_ovfl_y_isigned']
			testtemplate = rec['test_ovfl_templ_isigned']
			testcomment = rec['test_ovfl_comment_isigned']

		elif arraycode in codegen_common.unsignedint:
			test_op_x = rec['test_ovfl_x_iunsigned']
			test_op_y = rec['test_ovfl_y_iunsigned']
			testtemplate = rec['test_ovfl_templ_iunsigned']
			testcomment = rec['test_ovfl_comment_iunsigned']

		elif arraycode in codegen_common.floatarrays:
			test_op_x = rec['test_ovfl_x_float']
			test_op_y = rec['test_ovfl_y_float']
			testtemplate = rec['test_ovfl_templ_float']
			testcomment = rec['test_ovfl_comment_float']

		else:
			print('Unknow array code %s' % arraycode)


		# Split the individual test values out.
		xparamdata = test_op_x.split(',')
		yparamdata = test_op_y.split(',')

		# Split the list of test templates
		templatedata = testtemplate.split(',')
		# Split the comments.
		testcomment = testcomment.split(',')


		# Add in the byte converter for bytes data.
		if arraylabel == 'bytes':
			testrec['bytesconverterdata'] = bytesconverterdata
			testrec['bytesconverterdataout'] = bytesconverterdataout
		else:
			testrec['bytesconverterdata'] = ''
			testrec['bytesconverterdataout'] = ''

		testcount = 0
		# Create multiple tests.
		for template, xparam, yparam, comment in itertools.zip_longest(templatedata, xparamdata, yparamdata, testcomment):
			testcount += 1
			testrec['testcount'] = testcount
			testrec['ovfl_comment'] = comment
			testrec['ovfl_data'] = xparam
			testrec['ovfl_param2'] = yparam
			testresults.append(test_templates[template] % testrec)

	return ''.join(testresults)



# ==============================================================================

def makefloaterrortestset(csvdata, arraycode):
	"""Make a complete set of tests for floating point math library error tests.
	"""

	# Separate out the instructions which need to be checked for overflow.
	recdata = [x for x in csvdata if x['test_float_err_template'] != '']

	recset = []

	# Create the tests for one parameter.
	for instrdata in recdata:
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraycode
		testrec.update(instrdata)

		# Add in the test skip if this instruction is not supported on all platforms.
		if testrec['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformTestSkip
		else:
			testrec['skipplatform'] = ''


		template = test_templates[testrec['test_float_err_template']]
		recset.append(template % testrec)


	recset.append(classend)

	return ''.join(recset)

# ==============================================================================

def makenanparamtestset(csvdata, arraycode):
	"""Make a complete set of tests for floating point nan, inf, and -inf parameters.
	"""

	# Separate out the instructions which have floating point versions and 
	# which take one parameter.
	recdata = [x for x in csvdata if (x['c_code_template_float'] != '') and (x['#params'] != '0')]

	recset = []

	# Create the tests for one parameter.
	for instrdata in recdata:
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraycode
		testrec.update(instrdata)

		# Add in the test skip if this instruction is not supported on all platforms.
		if testrec['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformClassSkip
		else:
			testrec['skipplatform'] = ''


		recset.append(nan_param_template % testrec)


	return ''.join(recset)

# ==============================================================================

def makenandatatests(csvdata, arraycode):
	"""Make a complete set of tests for floating point nan, inf, and -inf data arrays.
	"""

	# Separate out the instructions which have floating point versions.
	recdata = [x for x in csvdata if x['test_nan_data_template'] != '']

	recset = []

	# Create the tests.
	for instrdata in recdata:

		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraycode
		testrec.update(instrdata)

		# Add in the test skip if this instruction is not supported on all platforms.
		if testrec['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformClassSkip
		else:
			testrec['skipplatform'] = ''

		# The equation for calculating the expected results.
		testrec['pyequ'] = testrec['py_equation'] % {'op' : testrec['pyoperator'], 'typeconvert' : ''}


		# Some tests are verified with known good data.
		testrec['xparamdata'] = testrec['test_op_x_float'].split(',')[0]

		nantemplate = test_templates[testrec['test_nan_data_template']]
		inftemplate = test_templates[testrec['test_inf_data_template']]
		ninftemplate = test_templates[testrec['test_ninf_data_template']]



		# Split the individual test values out.
		yparamvalues = testrec['test_op_y_float'].split(',')


		for seqnum, yparamdata in enumerate(yparamvalues):
			testrec['seq'] = seqnum

			# Construct the test class header.
			recset.append(nan_data_header_template % testrec)

			testrec['yparamdata'] = yparamdata

			# Construct the nan test text.
			testrec['testarray'] = 'nan'
			testrec['testlabel'] = 'nan'
			recset.append(nantemplate % testrec)

			# Construct the inf test text.
			testrec['testarray'] = 'inf'
			testrec['testlabel'] = 'inf'
			recset.append(inftemplate % testrec)

			# Construct the -inf test text.
			testrec['testarray'] = 'ninf'
			testrec['testlabel'] = '-inf'
			recset.append(ninftemplate % testrec)

			recset.append(classend)


	return ''.join(recset)



# ==============================================================================

def FormatHeaderDate(headerdate, seqnum):
	"""Format the date for the copyright header.
	"""
	headerdate['testfilename'] = 'test_amap' + str(seqnum)
	return codegen_common.HeaderTemplate % headerdate


def FormatFileName(seqnum):
	"""Format the file name.
	"""
	return 'test_amap' + str(seqnum) + '.py'


# ==============================================================================


# We need to add another code for bytes.
testarraycodes = list(codegen_common.arraycodes)
testarraylabels = list(codegen_common.arraycodes)
testarraycodes.append('B')
testarraylabels.append('bytes')

# ==============================================================================

# Data for the copyright header files.
headerdate = codegen_common.FormatHeaderData('test_amap', '23-May-2014', 'amap and amapi')

with open(FormatFileName(1), 'w') as f:
	# The copyright header.
	f.write(FormatHeaderDate(headerdate, 1))

	# This is a helper function required for these tests.
	f.write(InvertPy)

	# Basic operator tests.
	for arraycode, arraylabel in zip(testarraycodes, testarraylabels):
		f.write(type_template % codegen_common.arraytypeclass[arraylabel])
		f.write(''.join(makeoptests(csvdata, arraycode, arraylabel)))
	f.write(endtemplate)



with open(FormatFileName(2), 'w') as f:
	# The copyright header.
	f.write(FormatHeaderDate(headerdate, 2))

	# Output the generated code for overflow tests.
	for arraycode, arraylabel in zip(testarraycodes, testarraylabels):
		f.write(intoverflow_type_template % codegen_common.arraytypeclass[arraylabel])
		f.write(''.join(makeoverflowtestset(csvdata, arraycode, arraylabel)))


	# Output the generated code for floating point overflow tests.
	for arraycode in codegen_common.floatarrays:
		f.write(floaterror_class_template % codegen_common.arraytypeclass[arraycode])
		f.write(''.join(makefloaterrortestset(csvdata, arraycode)))

	# Test number and type of parameters.
	for arraylabel in testarraylabels:
		f.write(param_template % codegen_common.arraytypeclass[arraylabel])


	# Test for nan, inf, -inf in parameters.
	for arraycode in codegen_common.floatarrays:
		f.write(''.join(makenanparamtestset(csvdata, arraycode)))

	f.write(endtemplate)


# Tests involving NaN, inf, and -inf.
with open(FormatFileName(3), 'w') as f:
	# The copyright header.
	f.write(FormatHeaderDate(headerdate, 3))

	# Test for nan, inf, -inf in data.
	for arraycode in codegen_common.floatarrays:
		f.write(''.join(makenandatatests(csvdata, arraycode)))


	f.write(endtemplate)


# ==============================================================================

