#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Purpose:  Generate the unit tests for acalcvm.
# Language: Python 3.4
# Date:     12-Jan-2016
#
###############################################################################
#
#   Copyright 2014 - 2016    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################

# ==============================================================================

import itertools
import codegen_common

# ==============================================================================


# ==============================================================================

# The basic class template for testing each array type for operator function.
type_template = '''
##############################################################################
%(skiplonglong)sclass acalcvm_operator_%(typelabel)s(unittest.TestCase):
	"""Test for basic operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'

'''

# ==============================================================================


# This is a helper function required for some tests.
InvertPy = '''
##############################################################################
# The maximum values for selected array types.
IPLims = {'B' : arrayfunc.arraylimits.B_max , 'H' : arrayfunc.arraylimits.H_max, 
			'I' : arrayfunc.arraylimits.I_max, 'L' : arrayfunc.arraylimits.L_max, 
			'f' : arrayfunc.arraylimits.f_max, 'd' : arrayfunc.arraylimits.d_max}

# Add 'Q' arrays if this is supported on this platform.
if 'Q' in array.typecodes:
	IPLims['Q'] = arrayfunc.arraylimits.Q_max

def InvertPy(typecode, val):
	"""This allows for the invert operation to handle both signed and 
	unsigned integers.
	"""
	# Python native integers are signed.
	if typecode in ('b', 'h', 'i', 'l', 'q'):
		return ~val
	# Unsigned integers require more work to invert.
	else:
		maxval = IPLims[typecode]
		if val >= 0:
			return maxval - val
		else:
			return maxval + val


##############################################################################
'''

# ==============================================================================

# This is used to insert code to convert the test data to bytes type. 
bytesconverterdata = 'data = bytes(data)'
bytesconverterdataout = 'dataout = bytes(dataout)'

# This is the same with "self". 
bytesconverterdataself = 'self.data = bytes(self.data)'
bytesconverterdataoutself = 'self.dataout = bytes(self.dataout)'



# ==============================================================================

# With some platforms (Windows), the compiler does not support all functions.
# This means we cannot test for them.
PlatformClassSkip = """@unittest.skipIf(platform.python_compiler().startswith('MSC'), 'Skip test if not supported by the platform C compiler.')
"""

# This version is used for individual tests, as opposed to the entire class.
PlatformTestSkip = '\t' + PlatformClassSkip

# ==============================================================================

# ==============================================================================

# ==============================================================================


# The basic template for testing each array type for operator function where
# there is only the array variable. E.g. -x. 
# This covers acalcvm with overflow checking on and off.
test_template_1op = '''
	########################################################
%(skipplatform)s	def test_operator_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm %(oplabel)s  - Array code %(typelabel)s.
		"""
		# Template name: test_template_1op
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyop)s for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=False)

		%(assertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyop)s for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True)

		%(assertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_lim(self):
		"""Test acalcvm %(oplabel)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyop)s for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], maxlen=limited)

		%(assertoperation)s


	########################################################
%(skipplatform)s	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov_lim(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyop)s for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		%(assertoperation)s


'''


# ==============================================================================

# The basic template for testing each array type for operator function where
# there are two variables. E.g. x + y. 
# This covers acalcvm with overflow checking on and off.
test_template_2ops = '''
	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm %(oplabel)s  - Array code %(typelabel)s.
		"""
		# Template name: test_template_2ops
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyop)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=False)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [%(pyop)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_lim(self):
		"""Test acalcvm %(oplabel)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyop)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], maxlen=limited)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov_lim(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [%(pyop)s for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True, maxlen=limited)

		%(assertoperation)s


'''

# ==============================================================================

# ==============================================================================

# The special template for testing each array type for integer divide / function.
# This covers acalcvm with overflow checking on and off.
test_template_intdiv = '''
	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm %(oplabel)s  - Array code %(typelabel)s.
		"""
		# Template name: test_template_intdiv
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=False)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		expected = [int(x / y) for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_lim(self):
		"""Test acalcvm %(oplabel)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], maxlen=limited)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov_lim(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		# We need to convert to integer, as the underlying C
		# divide does integer division with integer arrays.
		pydataout = [int(x / y) for x,y in zip(list(data), itertools.repeat(%(yparamdata)s))]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True, maxlen=limited)

		%(assertoperation)s


'''

# ==============================================================================

# The special template for testing each array type for integer invert ~ function.
# This covers acalcvm with overflow checking on and off.
test_template_intinvert = '''
	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm %(oplabel)s  - Array code %(typelabel)s.
		"""
		# Template name: test_template_intinvert
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [InvertPy('%(typecode)s', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=False)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		expected = [InvertPy('%(typecode)s', x) for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_lim(self):
		"""Test acalcvm %(oplabel)s with array limit  - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [InvertPy('%(typecode)s', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], maxlen=limited)

		%(assertoperation)s


	########################################################
	def test_operator_%(oplabel)s_%(testcount)s_acalcvm_ov_lim(self):
		"""Test acalcvm %(oplabel)s with overflow checking disabled and array limit - Array code %(typelabel)s.
		"""
		data = array.array('%(typecode)s', [%(test_op_x)s])
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s
		limited = len(data) // 2

		pydataout = [InvertPy('%(typecode)s', x) for x in list(data)]
		expected = pydataout[0:limited] + list(dataout)[limited:]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True, maxlen=limited)

		%(assertoperation)s


'''

# ==============================================================================

# ==============================================================================
# These templates handle whether to do exact compares with integer arrays, or
# approximate compares with floating point compares.

# This bit is not a complete template, but rather is used to complete some of the other templates.
almost_template = """
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)
"""

exact_template = "self.assertEqual(list(dataout), expected)"
almost_template = "for dataoutitem, expecteditem in zip(list(dataout), expected):" + almost_template


# ==============================================================================


# ==============================================================================


# The basic class template for testing each array type for integer overflow.
intoverflow_type_template = '''
##############################################################################
%(skiplonglong)sclass acalcvm_intoverflow_%(typelabel)s(unittest.TestCase):
	"""Test for integer overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min


'''

# Test for integer overflows.
intoverflow_template_2ops = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_2ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([%(ovfl_param2)s])


'''


# Test for integer overflows.
intoverflow_template_1ops = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_1ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


'''




# We should get an integer overflow error even when disabled as some tests
# cannot be disabled.
intoverflow_template_nodis_2ops = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_nodis_2ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([%(ovfl_param2)s], disovfl=True)


'''

# As above, but without a second variable.
intoverflow_template_nodis_1ops = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_disabled_acalcvm(self):
		"""Test acalcvm integer overflow checking disabled in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_nodis_1ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([], disovfl=True)


'''






# This template uses no second parameter.
intoverflow_template_noparam = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_noparam
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


'''


# This template uses no second parameter and overflow is not checked.
intoverflow_template_noparam_ovldis = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm integer overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: intoverflow_template_noparam_ovldis
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		expected = [%(pyop)s for x in list(data)]

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=False)

		%(assertoperation)s


'''


intfuncoverflow_template_noparam = '''
	########################################################
	def test_intoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm integer overflow in %(opcodename)s  - Array code %(typelabel)s.
		"""
		# Template name: intfuncoverflow_template_noparam
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*len(data))
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])


'''


# ==============================================================================


# Floating point overflow test without a second operand.
floatoverflow_template_1ops = '''
	########################################################
	def test_floatoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: floatoverflow_template_1ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])

'''

# Floating point overflow test with a second operand.
floatoverflow_template_2ops = '''
	########################################################
	def test_floatoverflow_%(oplabel)s_%(testcount)s_acalcvm(self):
		"""Test acalcvm floating point overflow in %(opcodename)s  - Array code %(typelabel)s - %(ovfl_comment)s.
		"""
		# Template name: floatoverflow_template_2ops
		data = array.array('%(typecode)s', [%(ovfl_data)s]*10)
		%(bytesconverterdata)s
		dataout = array.array('%(typecode)s', [0]*10)
		%(bytesconverterdataout)s

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([%(ovfl_param2)s])

'''

# ==============================================================================

# The basic class template for testing each floating point library item for math errors.
floaterror_class_template = '''
##############################################################################
%(skiplonglong)sclass acalcvm_floaterror_%(typelabel)s(unittest.TestCase):
	"""Test for floating point overflow operator function.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min


'''

# Math functions which take one parameter.
floaterror_template_1ops = '''
	########################################################
%(skipplatform)s	def test_floaterror_%(oplabel)s_acalcvm(self):
		"""Test acalcvm floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		# Template name: floaterror_template_1ops
		data = array.array('%(typecode)s', range(%(test_float_err_x)s))
		dataout = array.array('%(typecode)s', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', [])

		with self.assertRaises(OverflowError):
			eqnd.execute([])

'''



# Math functions which take two parameters.
floaterror_template_2ops = '''
	########################################################
	def test_floaterror_%(oplabel)s_acalcvm(self):
		"""Test acalcvm floating point error in %(opcodename)s  - Array code %(typelabel)s.
		"""
		# Template name: floaterror_template_2ops
		data = array.array('%(typecode)s', [%(test_float_err_x)s])
		dataout = array.array('%(typecode)s', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])

		with self.assertRaises(OverflowError):
			eqnd.execute([%(test_float_err_y)s])

'''


# ==============================================================================

# The basic class template for testing overflow of the parameters with integer arrays.
int_template_ovfl_param = '''
##############################################################################
class acalcvm_ovfl_param_%(typelabel)s(unittest.TestCase):
	"""Test for basic operator function.
	"""
	# Template name: int_template_ovfl_param

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.MaxLimit = arrayfunc.arraylimits.%(typecode)s_max
		self.MinLimit = arrayfunc.arraylimits.%(typecode)s_min

		self.data = array.array('%(typecode)s', [0, 1, 2, 3, 4, 5] * 10)
		%(bytesconverterdataself)s
		self.dataout = array.array('%(typecode)s', [0]*len(self.data))
		%(bytesconverterdataoutself)s


	########################################################
	def test_int_ovfl_param_max_01_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking on - Array code %(typelabel)s.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_max_02_acalcvm(self):
		"""Test acalcvm overflow of parameters with max value and overflow checking off - Array code %(typelabel)s.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MaxLimit - 5], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MaxLimit + 1], disovfl=True)


	########################################################
	def test_int_ovfl_param_min_03_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking on - Array code %(typelabel)s.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=False)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=False)


	########################################################
	def test_int_ovfl_param_min_04_acalcvm(self):
		"""Test acalcvm overflow of parameters with min value and overflow checking off - Array code %(typelabel)s.
		"""
		eqnd = arrayfunc.acalc.calc(self.data, self.dataout)
		eqnd.comp('x + y', 'x', ['y'])

		# This should pass.
		eqnd.execute([self.MinLimit], disovfl=True)

		# This is the actual test.
		with self.assertRaises(OverflowError):
			eqnd.execute([self.MinLimit - 1], disovfl=True)


'''


# ==============================================================================

# ==============================================================================

# The template used to start off the tests for nan, inf, -inf in data arrays.
nan_data_header_template = '''
##############################################################################
%(skipplatform)sclass acalcvm_nan_data_%(oplabel)s_%(seq)s_%(typelabel)s(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('%(typecode)s', [%(xparamdata)s] * 10)
		self.dataok = array.array('%(typecode)s', [%(xparamdata)s] * 10)

		self.dataout = array.array('%(typecode)s', itertools.repeat(0.0, 10))

		self.datainf = array.array('%(typecode)s', [float('inf')] * 10)
		self.datanan = array.array('%(typecode)s', [float('nan')] * 10)
		self.dataninf = array.array('%(typecode)s', [float('-inf')] * 10)

'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected.
nan_data_error_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Template name: nan_data_error_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s])

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([%(yparamdata)s])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)

'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and a second parameter is present.
nan_data_error_param_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Template name: nan_data_error_param_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([%(yparamdata)s])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and no second parameter is present. When overflow
# checking is turned off, the results are checked.
nan_data_errorchecked_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		# Template name: nan_data_errorchecked_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''




# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected and no second parameter is present.
nan_data_error_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		# Template name: nan_data_error_noparam_template
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True)

'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are not expected and no second parameter is present. 
nan_data_noerror_noparam_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking on and single parameter functions  - Array code %(typelabel)s.
		"""
		# Template name: nan_data_noerror_noparam_template
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([])

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off and single parameter functions  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x in self.data%(testarray)s]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', [])
		eqnd.execute([], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for af_mod, and af_mod_r.
nan_data_af_mod_error_param_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Template name: nan_data_af_mod_error_param_template
		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s])

		# This is the actual test. We always expect NaN to raise errors.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		with self.assertRaises(ArithmeticError):
			eqnd.execute([%(yparamdata)s])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''



# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for pow since raising
# any value to 0 will always return 1.
nan_data_powerror_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Template name: nan_data_powerror_template
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
				(('%(opcodename)s' in ('pow', 'math.pow')) and (%(yparamdata)s == 0.0))):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s])

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([%(yparamdata)s])
		else:
			eqnd.execute([%(yparamdata)s])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.data%(testarray)s)

		# MSVC sometimes give different results from Python or GCC.
		if (platform.python_compiler().startswith('MSC') and ('%(testarray)s' == 'nan') and
				(('%(opcodename)s' in ('pow', 'math.pow')) and (%(yparamdata)s == 0.0))):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are not expected.
nan_data_noerror_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking on and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Template name: nan_data_noerror_template
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s])


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off and param data of %(yparamdata)s  - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]

		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)


		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''


# The template used to generate the tests for nan, inf, -inf in data arrays
# when exceptions are expected. This is a special version for fmod, and fmod_r.
nan_data_fmoderror_param_template = '''
	########################################################
	def test_%(testarray)s_%(oplabel)s_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s where an error is expected - Array code %(typelabel)s.
		"""
		# Template name: nan_data_fmoderror_param_template
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This version is expected to pass.
		eqnd = arrayfunc.acalc.calc(self.dataok, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s])


		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				eqnd.execute([%(yparamdata)s])
		else:
			eqnd.execute([%(yparamdata)s])


	########################################################
	def test_%(testarray)s_%(oplabel)s_ov_acalcvm(self):
		"""Test acalcvm for data of %(testlabel)s with overflow checking off - Array code %(typelabel)s.
		"""
		# Calculate the expected result.
		try:
			expected = [%(pyequ)s for x,y in zip(list(self.data%(testarray)s), itertools.repeat(%(yparamdata)s))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.data%(testarray)s)

		# MSVC sometimes gives different results from Python or GCC.
		if platform.python_compiler().startswith('MSC'):
			expected = [float('nan')] * len(self.data%(testarray)s)


		# This is the actual test.
		eqnd = arrayfunc.acalc.calc(self.data%(testarray)s, self.dataout)
		eqnd.comp('%(pyop)s', 'x', ['y'])
		eqnd.execute([%(yparamdata)s], disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


'''

# ==============================================================================

# The basic class template for testing each array type for operator function.
platform_template = '''
##############################################################################
class acalcvm_platform_%(typelabel)s(unittest.TestCase):
	"""Test for function platform function.
	"""
	# Template name: platform_template

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.ismsvc = platform.python_compiler().startswith('MSC')

'''


# The basic template for testing platform support.
test_template_platform_has = '''
	########################################################
	def test_platform_op_%(oplabel)s_acalcvm(self):
		"""Test acalcvm %(oplabel)s for platform support - Array code %(typelabel)s.
		"""
		# Template name: test_template_platform_has

		data = array.array('%(typecode)s', [%(test_platform_x)s])
		dataout = array.array('%(typecode)s', [0]*len(data))

		eqnd = arrayfunc.acalc.calc(data, dataout)
		# If the function lacks compiler support, then tell the compiler to 
		# remove those operations from its list of unsupported ops.
		if self.ismsvc:
			eqnd._UnsupportedCodes = []

		eqnd.comp('%(pyop)s', 'x', [])

		# The response depends upon the platform the C compiler used. 
		# MSVC 2010 does not support some math functions. The test is simply
		# whether or not an exception is raised.
		if self.ismsvc:
			with self.assertRaises(ValueError):
				eqnd.execute([])
		else:
			eqnd.execute([])


'''


# ==============================================================================


# The basic class template for testing variable offsets and stack check.
arraycheck_template = '''
##############################################################################
class acalcvm_arraycheck_%(typelabel)s(unittest.TestCase):
	"""Test for VM control data array checks.
	"""
	# Template name: arraycheck_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'

		data = array.array('%(typecode)s', [1, 2, 3, 4, 5] * 10)
		dataout = array.array('%(typecode)s', [0]*len(data))

		# Set up the equation ready to execute.
		self.eqnd = arrayfunc.acalc.calc(data, dataout)

'''



# This is for testing the functions checkstackerror and checkvaroffsets. 
test_template_arraycheck = '''
	########################################################
	def test_checkvaroffsets_ok_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - This should pass - Array code %(typelabel)s.
		"""
		# Template name: test_template_arraycheck

		# This should pass.
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_first_offset_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from first variable - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[0] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkvaroffsets_second_offset_offset_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkvaroffsets - Array offset from second variable - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])
		# Modify the variable offset array.
		self.eqnd._varoffsetarray[1] = len(self.eqnd._varoffsetarray) + 1

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm variable array overflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_first_opcode_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkstackerror - First op code is not a push - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code. The integer and float values should be the
		# same for ths op code, but we won't count on it. 
		if '%(typelabel)s' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval

		self.eqnd._codearray[0] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_unknown_opcode_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkstackerror - Op code is unknown - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify the first op code to something greater than the max value.  
		if '%(typelabel)s' in ('f', 'd'):
			testval = max(arrayfunc.acalc._OpCodesFloat.values()) + 1
		else:
			testval = max(arrayfunc.acalc._OpCodesInt.values()) + 1

		self.eqnd._codearray[1] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm uknown op code.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackoverflow_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack overflow - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if '%(typelabel)s' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['pusharray'].floatval
			addval = arrayfunc.acalc._OpCodes['add'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['pusharray'].intval
			addval = arrayfunc.acalc._OpCodes['add'].intval

		# Find the first add opcode.
		addpos = self.eqnd._codearray.index(addval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[addpos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


	########################################################
	def test_checkstackerror_stackunderflow_%(typelabel)s_acalcvm(self):
		"""Test acalcvm for checkstackerror - Stack underflow - Array code %(typelabel)s.
		"""
		self.eqnd.comp('x + y + z', 'x', ['y', 'z'])

		# Modify all the op codes to ones which add to the stack. 
		if '%(typelabel)s' in ('f', 'd'):
			testval = arrayfunc.acalc._OpCodes['add'].floatval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval
		else:
			testval = arrayfunc.acalc._OpCodes['add'].intval
			pusharrayval = arrayfunc.acalc._OpCodes['pusharray'].floatval

		# Find the first pusharray opcode.
		pusharraypos = self.eqnd._codearray.index(pusharrayval)

		codearraytype = self.eqnd._codearray.typecode
		self.eqnd._codearray[pusharraypos] = testval

		# Expect an exception.
		with self.assertRaisesRegex(ValueError, 'ACalc vm stack overflow or underflow.'):
			self.eqnd.execute([2, 3])


'''


# ==============================================================================

# These are all the test code templates. 
test_templates = {'test_template_2ops' : test_template_2ops,
				'test_template_1op' : test_template_1op,
				'test_template_intdiv' : test_template_intdiv,
				'test_template_intinvert' : test_template_intinvert,
				'intoverflow_template_nodis_1ops' : intoverflow_template_nodis_1ops,
				'intoverflow_template_nodis_2ops' : intoverflow_template_nodis_2ops,
				'intoverflow_template_noparam' : intoverflow_template_noparam,
				'intfuncoverflow_template_noparam' : intfuncoverflow_template_noparam,
				'intoverflow_template_1ops' : intoverflow_template_1ops,
				'intoverflow_template_2ops' : intoverflow_template_2ops,
				'floatoverflow_template_1ops' : floatoverflow_template_1ops,
				'floatoverflow_template_2ops' : floatoverflow_template_2ops,
				'floaterror_template_1ops' : floaterror_template_1ops,
				'floaterror_template_2ops' : floaterror_template_2ops,
				'nan_data_error_template' : nan_data_error_template,
				'nan_data_error_param_template' : nan_data_error_param_template,
				'nan_data_errorchecked_noparam_template' : nan_data_errorchecked_noparam_template,
				'nan_data_error_noparam_template' : nan_data_error_noparam_template,
				'nan_data_noerror_noparam_template' : nan_data_noerror_noparam_template,
				'nan_data_af_mod_error_param_template' : nan_data_af_mod_error_param_template,
				'nan_data_powerror_template' : nan_data_powerror_template,
				'nan_data_noerror_template' : nan_data_noerror_template,
				'nan_data_fmoderror_param_template' : nan_data_fmoderror_param_template,
				'int_template_ovfl_param' : int_template_ovfl_param,
				'test_template_platform_has' : test_template_platform_has,

}

# ==============================================================================

# ==============================================================================

classend = """##############################################################################
"""


endtemplate = """
##############################################################################
if __name__ == '__main__':
    unittest.main()

##############################################################################
"""


# ==============================================================================

def makeoptests(csvdata, arraycode, arraylabel):
	"""Make a complete set of tests for all operations for all array types.
	"""

	# The type of unit test assert we use for testing the results depends on
	# whether we are comparing floating point or integer values.
	if arraycode in codegen_common.signedint:
		opdata = [x for x in csvdata if x['test_op_templ_isigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.unsignedint:
		opdata = [x for x in csvdata if x['test_op_templ_iunsigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.floatarrays:
		opdata = [x for x in csvdata if x['test_op_templ_float'] != '']
		typeconvert = 'float'

	else:
		print('Unknow array code %s' % arraycode)
		typecode = arraycode


	# Create the records.
	testresults = []
	for rec in opdata:
		# Avoid changing the original record.
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraylabel
		# Sanitize math function names which are used in test method names.
		testrec['oplabel'] = rec['opcodename'].replace('.', '_')

		testrec.update(rec)

		if arraycode in codegen_common.signedint:
			test_op_x = rec['test_op_x_isigned']
			test_op_y = rec['test_op_y_isigned']
			testtemplate = test_templates[rec['test_op_templ_isigned']]
			testrec['assertoperation'] = exact_template

		elif arraycode in codegen_common.unsignedint:
			test_op_x = rec['test_op_x_iunsigned']
			test_op_y = rec['test_op_y_iunsigned']
			testtemplate = test_templates[rec['test_op_templ_iunsigned']]
			testrec['assertoperation'] = exact_template

		elif arraycode in codegen_common.floatarrays:
			test_op_x = rec['test_op_x_float']
			test_op_y = rec['test_op_y_float']
			testtemplate = test_templates[rec['test_op_templ_float']]
			testrec['assertoperation'] = almost_template

		else:
			print('Unknow array code %s' % arraycode)


		testrec['pyop'] = rec['opcodedocs']
		testrec['test_op_x'] = test_op_x

		# Split the individual test values out.
		yparamdata = test_op_y.split(',')


		# Add in the byte converter for bytes data.
		if arraylabel == 'bytes':
			testrec['bytesconverterdata'] = bytesconverterdata
			testrec['bytesconverterdataout'] = bytesconverterdataout
		else:
			testrec['bytesconverterdata'] = ''
			testrec['bytesconverterdataout'] = ''


		# Add in the test skip if this instruction is not supported on all platforms.
		if rec['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformTestSkip
		else:
			testrec['skipplatform'] = ''


		# Generate a test for each test data element.
		testcount = 0
		for testval in yparamdata:
			testcount += 1
			testrec['testcount'] = testcount
			testrec['yparamdata'] = testval
			testresults.append(testtemplate % testrec)


	return ''.join(testresults)



# ==============================================================================


# ==============================================================================

def makeplatformtests(csvdata, arraycode, arraylabel):
	"""Make a set of tests to check platform compiler support. MSVC 2010 does 
	not support some required math operations, and so some math functions are 
	not supported when compiler for and run on an MS Windows platform. This test
	checks to see that these functions pass on GCC compatible platforms, but
	cause an exception on MS Windows. 
	"""

	# We expect floating point arrays only. Also, we need to filter out everything
	# except functions which MSVC does not support.
	if arraycode in codegen_common.floatarrays:
		opdata = [x for x in csvdata if x['test_platform_has'] != '']

	else:
		print('Wrong or unknow array code %s' % arraycode)
		typecode = arraycode


	# Create the records.
	testresults = []
	for rec in opdata:
		# Avoid changing the original record.
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraylabel
		# Sanitize math function names which are used in test method names.
		testrec['oplabel'] = rec['opcodename'].replace('.', '_')

		testrec.update(rec)

		test_op_x = rec['test_platform_x']
		testtemplate = test_templates[rec['test_platform_has']]

		testrec['pyop'] = rec['opcodedocs']

		# Generate a test for each test data element.
		testresults.append(testtemplate % testrec)


	return ''.join(testresults)



# ==============================================================================

# ==============================================================================

def makeoverflowtestset(csvdata, arraycode, arraylabel):
	"""Make a complete set of tests for overflow tests.
	"""
	# The type of unit test assert we use for testing the results depends on
	# whether we are comparing floating point or integer values.
	if arraycode in codegen_common.signedint:
		opdata = [x for x in csvdata if x['test_ovfl_templ_isigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.unsignedint:
		opdata = [x for x in csvdata if x['test_ovfl_templ_iunsigned'] != '']
		typeconvert = 'int'

	elif arraycode in codegen_common.floatarrays:
		opdata = [x for x in csvdata if x['test_ovfl_templ_float'] != '']
		typeconvert = 'float'

	else:
		print('Unknow array code %s' % arraycode)
		typecode = arraycode


	# Create the records.
	testresults = []
	for rec in opdata:
		# Avoid changing the original record.
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraylabel
		# Sanitize math function names which are used in test method names.
		testrec['oplabel'] = rec['opcodename'].replace('.', '_')

		testrec.update(rec)

		if arraycode in codegen_common.signedint:
			test_op_x = rec['test_ovfl_x_isigned']
			test_op_y = rec['test_ovfl_y_isigned']
			testtemplate = rec['test_ovfl_templ_isigned']
			testcomment = rec['test_ovfl_comment_isigned']

		elif arraycode in codegen_common.unsignedint:
			test_op_x = rec['test_ovfl_x_iunsigned']
			test_op_y = rec['test_ovfl_y_iunsigned']
			testtemplate = rec['test_ovfl_templ_iunsigned']
			testcomment = rec['test_ovfl_comment_iunsigned']

		elif arraycode in codegen_common.floatarrays:
			test_op_x = rec['test_ovfl_x_float']
			test_op_y = rec['test_ovfl_y_float']
			testtemplate = rec['test_ovfl_templ_float']
			testcomment = rec['test_ovfl_comment_float']

		else:
			print('Unknow array code %s' % arraycode)

		testrec['pyop'] = rec['opcodedocs']

		# Split the individual test values out.
		xparamdata = test_op_x.split(',')
		yparamdata = test_op_y.split(',')

		# Split the list of test templates
		templatedata = testtemplate.split(',')
		# Split the comments.
		testcomment = testcomment.split(',')


		# Add in the byte converter for bytes data.
		if arraylabel == 'bytes':
			testrec['bytesconverterdata'] = bytesconverterdata
			testrec['bytesconverterdataout'] = bytesconverterdataout
		else:
			testrec['bytesconverterdata'] = ''
			testrec['bytesconverterdataout'] = ''

		testcount = 0
		# Create multiple tests.
		for template, xparam, yparam, comment in itertools.zip_longest(templatedata, xparamdata, yparamdata, testcomment):
			testcount += 1
			testrec['testcount'] = testcount
			testrec['ovfl_comment'] = comment
			testrec['ovfl_data'] = xparam
			testrec['ovfl_param2'] = yparam
			testresults.append(test_templates[template] % testrec)

	return ''.join(testresults)



# ==============================================================================

# ==============================================================================

def makefloaterrortestset(csvdata, arraycode):
	"""Make a complete set of tests for floating point math library error tests.
	"""

	# Separate out the instructions which need to be checked for overflow.
	recdata = [x for x in csvdata if x['test_float_err_template'] != '']

	recset = []


	# Create the tests for one parameter.
	for instrdata in recdata:
		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraycode
		testrec['opcodename'] = instrdata['opcodename']
		# Sanitize math function names which are used in test method names.
		testrec['oplabel'] = instrdata['opcodename'].replace('.', '_')

		testrec['pyop'] = instrdata['opcodedocs']


		# Add in the test skip if this instruction is not supported on all platforms.
		if instrdata['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformTestSkip
		else:
			testrec['skipplatform'] = ''

		testrec['test_float_err_x'] = instrdata['test_float_err_x']
		testrec['test_float_err_y'] = instrdata['test_float_err_y']


		template = test_templates[instrdata['test_float_err_template']]
		recset.append(template % testrec)


	recset.append(classend)

	return ''.join(recset)

# ==============================================================================

# ==============================================================================

def makenandatatests(csvdata, arraycode):
	"""Make a complete set of tests for floating point nan, inf, and -inf data arrays.
	"""

	# Separate out the instructions which have floating point versions.
	recdata = [x for x in csvdata if x['test_nan_data_template'] != '']

	recset = []


	# Create the tests.
	for instrdata in recdata:

		testrec = {}
		testrec['typecode'] = arraycode
		testrec['typelabel'] = arraycode
		# Sanitize math function names which are used in test method names.
		testrec['oplabel'] = instrdata['opcodename'].replace('.', '_')

		testrec['pyop'] = instrdata['opcodedocs']


		# Add in the test skip if this instruction is not supported on all platforms.
		if instrdata['msvs_has'] == '0':
			testrec['skipplatform'] = PlatformClassSkip
		else:
			testrec['skipplatform'] = ''

		testrec['opcodename'] = instrdata['opcodename']

		# The equation for calculating the expected results.
		testrec['pyequ'] = instrdata['opcodedocs']


		# Some tests are verified with known good data.
		testrec['xparamdata'] = instrdata['test_op_x_float'].split(',')[0]

		nantemplate = test_templates[instrdata['test_nan_data_template']]
		inftemplate = test_templates[instrdata['test_inf_data_template']]
		ninftemplate = test_templates[instrdata['test_ninf_data_template']]



		# Split the individual test values out.
		yparamvalues = instrdata['test_op_y_float'].split(',')


		for seqnum, yparamdata in enumerate(yparamvalues):
			testrec['seq'] = seqnum

			# Construct the test class header.
			recset.append(nan_data_header_template % testrec)

			testrec['yparamdata'] = yparamdata

			# Construct the nan test text.
			testrec['testarray'] = 'nan'
			testrec['testlabel'] = 'nan'
			recset.append(nantemplate % testrec)

			# Construct the inf test text.
			testrec['testarray'] = 'inf'
			testrec['testlabel'] = 'inf'
			recset.append(inftemplate % testrec)

			# Construct the -inf test text.
			testrec['testarray'] = 'ninf'
			testrec['testlabel'] = '-inf'
			recset.append(ninftemplate % testrec)

			recset.append(classend)


	return ''.join(recset)



# ==============================================================================

# ==============================================================================

# We need to add another code for bytes.
testarraycodes = list(codegen_common.arraycodes)
testarraylabels = list(codegen_common.arraycodes)

testarraycodes.append('B')
testarraylabels.append('bytes')

# ==============================================================================

# ==============================================================================

# Read the operator and function definition data.
csvdata = codegen_common.ReadCSVData('arraycalc.csv')


# ==============================================================================

# Data for the copyright header files.
headerdate = codegen_common.FormatHeaderData('test_acalcvm', '28-Jan-2016', 'acalc')

with open('test_acalcvm.py', 'w') as f:
	# The copyright header.
	f.write(codegen_common.HeaderTemplate % headerdate)

	# This is a helper function required for these tests.
	f.write(InvertPy)

	####################################################################

	# Output the generated code for basic operator tests.
	for arraycode, arraylabel in zip(testarraycodes, testarraylabels):
		f.write(type_template % codegen_common.arraytypeclass[arraylabel])
		f.write(''.join(makeoptests(csvdata, arraycode, arraylabel)))
		f.write(classend)

	####################################################################

	# Output the generated code for overflow tests.
	for arraycode, arraylabel in zip(testarraycodes, testarraylabels):
		f.write(intoverflow_type_template % codegen_common.arraytypeclass[arraylabel])
		f.write(''.join(makeoverflowtestset(csvdata, arraycode, arraylabel)))
		f.write(classend)

	####################################################################

	# Output the generated code for floating point overflow tests.
	for arraycode in codegen_common.floatarrays:
		f.write(floaterror_class_template % codegen_common.arraytypeclass[arraycode])
		f.write(''.join(makefloaterrortestset(csvdata, arraycode)))

	####################################################################

	# Output the generated code for overflow tests for parameters in integer arrays.
	for arraycode in codegen_common.intarrays:
		templatedata = dict(codegen_common.arraytypeclass[arraycode])
		templatedata.update({'bytesconverterdataself' : '', 'bytesconverterdataoutself' : ''})
		f.write(int_template_ovfl_param % templatedata)
		f.write(classend)

	# For bytes data.
	templatedata = dict(codegen_common.arraytypeclass['bytes'])
	templatedata.update({'bytesconverterdataself' : bytesconverterdataself, 
					'bytesconverterdataoutself' : bytesconverterdataoutself})
	f.write(int_template_ovfl_param % templatedata)
	f.write(classend)

	####################################################################

	# Test for nan, inf, -inf in data.
	for arraycode in codegen_common.floatarrays:
		f.write(''.join(makenandatatests(csvdata, arraycode)))


	####################################################################

	# Output the generated code for platform support. The MSVC 2010 compiler
	# does not support all math functions
	for arraycode in codegen_common.floatarrays:
		f.write(platform_template % codegen_common.arraytypeclass[arraycode])
		f.write(''.join(makeplatformtests(csvdata, arraycode, arraycode)))
		f.write(classend)

	####################################################################

	# Output the generated code for VM array overflow tests. These tests check
	# that array overflows will not occur in the data arrays that store the
	# stack and data array offset pointers.
	for arraycode, arraylabel in zip(testarraycodes, testarraylabels):
		f.write(arraycheck_template % codegen_common.arraytypeclass[arraylabel])

		templatedata = dict(codegen_common.arraytypeclass[arraylabel])
		templatedata.update({'bytesconverterdataself' : '', 'bytesconverterdataoutself' : ''})
		f.write(test_template_arraycheck % templatedata)
		f.write(classend)


	####################################################################

	f.write(endtemplate)

