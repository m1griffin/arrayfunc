#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Purpose:  Generate the unit tests for acalc.
# Language: Python 3.4
# Date:     05-Feb-2016
#
###############################################################################
#
#   Copyright 2014 - 2016    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################

# ==============================================================================

import codegen_common
import itertools

# ==============================================================================

# This data is required for testing constant conversions.
InvertPy = '''
##############################################################################
# The maximum values for selected array types.
IPLims = {'B' : arrayfunc.arraylimits.B_max , 'H' : arrayfunc.arraylimits.H_max, 
			'I' : arrayfunc.arraylimits.I_max, 'L' : arrayfunc.arraylimits.L_max, 
			'f' : arrayfunc.arraylimits.f_max, 'd' : arrayfunc.arraylimits.d_max}

# Add 'Q' arrays if this is supported on this platform.
if 'Q' in array.typecodes:
	IPLims['Q'] = arrayfunc.arraylimits.Q_max

##############################################################################
'''

# ==============================================================================

# This is used to insert code to convert the test data to bytes type. 
bytesconverterdata = 'self.data = bytes(self.data)'
bytesconverterdataout = 'self.dataout = bytes(self.dataout)'

# ==============================================================================


# The basic template for testing each array type for calc init function.
calc_init_template = '''
##############################################################################
class acalcccomp_calc_init_%(typelabel)s(unittest.TestCase):
	"""Test for basic class initialisation.
	"""
	# Template: calc_init_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile_init_arraytypes(self):
		"""Test acalc compile init array types  - Array code %(typelabel)s.
		"""
		self.assertEqual(self.eqn._ArrayType, self.TypeCode)


	########################################################
	def test_compile_init_arrayclass(self):
		"""Test acalc compile init array classes (float or int)  - Array code %(typelabel)s.
		"""
		self.assertEqual(self.eqn._DataType, '%(typeclass)s')


	########################################################
	def test_compile_init_paramtypes_01(self):
		"""Test acalc compile init parameter types for first array  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(1, self.dataout)


	########################################################
	def test_compile_init_paramtypes_02(self):
		"""Test acalc compile init parameter types for second array  - Array code %(typelabel)s.
		"""
		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, 1)


##############################################################################

'''



# The basic template for testing array type mismatch for calc init function.
calc_init_mismatch_template = '''
##############################################################################
class acalcccomp_calc_init_mismatch(unittest.TestCase):
	"""Test for basic class initialisation array type mismatch.
	"""
	# Template: calc_init_mismatch_template


'''


# ==============================================================================

calc_init_mismatch_1_template = '''

	########################################################
	def test_compile_init_mismatch_arraytypes_%(typelabel1)s_%(typelabel2)s(self):
		"""Test acalc compile init array types  - Input array code %(typelabel1)s, output array code %(typelabel2)s.
		"""
		self.DataLen = 1000
		self.data = array.array('%(typecode1)s', [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array('%(typecode2)s', [0] * len(self.data))
		%(bytesconverterdataout)s

		with self.assertRaises(TypeError):
			self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

'''

calc_init_mismatch_2_template = '''

##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for platform compiler math support.
calc_init_platform_math_template = '''
##############################################################################
class acalcccomp_platform_math_%(typelabel)s(unittest.TestCase):
	"""Test for platform math support.
	This test is redundant if MSVC 2010 is replaced by a compiler with full 
	support on Windows for all math functions.
	"""
	# Template: calc_init_platform_math_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)

		self.ismsvc = platform.python_compiler().startswith('MSC')


	########################################################
	def test_platform_math_support_00(self):
		"""Test acalc for platform math support in the init for the current platform - Array code %(typelabel)s.
		"""
		# If this is running on an MSVC platform, there should be a list of
		# unsupported ops.
		if self.ismsvc:
			self.assertGreater(len(self.eqn._UnsupportedCodes), 0)
		# Otherwise, there should be no unsupported ops.
		else:
			self.assertEqual(len(self.eqn._UnsupportedCodes), 0)


##############################################################################

'''


# ==============================================================================

# ==============================================================================


# The basic template for testing each array type for calc compile function.
calc_comp_template = '''
##############################################################################
class acalcccomp_calc_comp_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)



	########################################################
	def test_compile_reserved_words_as_variables_00(self):
		"""Test acalc compile comp reserved words as variables - "abs" may not be a variable name  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, '"abs" may not be used as a variable name in ACalc compile.'):
			self.eqn.comp('abs + 1', 'abs', ())


	########################################################
	def test_compile_reserved_words_as_variables_01(self):
		"""Test acalc compile comp reserved words as variables - abs, try, def may not be a variable name  - Array code %(typelabel)s.
		"""
		# Use a regex in testing the error message, since we don't know the order 
		# the multiple results will come out in. 
		with self.assertRaisesRegex(ValueError, '"...", "...", "..." may not be used as a variable name in ACalc compile.$'):
			self.eqn.comp('abs + 1 + if + def', 'abs', ('try', 'def'))


	########################################################
	def test_compile_invalid_tokens_arrayclass_00(self):
		"""Test acalc compile comp unbalanced parentheses - this should pass  - Array code %(typelabel)s.
		"""
		self.eqn.comp('x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_01(self):
		"""Test acalc compile comp unbalanced parentheses check left  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('(x + 1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_02(self):
		"""Test acalc compile comp unbalanced parentheses check right  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unbalanced parentheses in ACalc compile.'):
			self.eqn.comp('x + 1)', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_03(self):
		"""Test acalc compile comp invalid tokens - `  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError,  'invalid tokens in ACalc compile: \`.'):
			self.eqn.comp('x + `1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_04(self):
		"""Test acalc compile comp invalid tokens - @  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: @.'):
			self.eqn.comp('x + @1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_05(self):
		"""Test acalc compile comp invalid tokens - #  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: #.'):
			self.eqn.comp('x + #1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_06(self):
		"""Test acalc compile comp invalid tokens - $  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \$.'):
			self.eqn.comp('x + $1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_07(self):
		"""Test acalc compile comp invalid tokens - ;  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: ;.'):
			self.eqn.comp('x + ;1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_08(self):
		"""Test acalc compile comp invalid tokens - :  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: :.'):
			self.eqn.comp('x + :1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_09(self):
		"""Test acalc compile comp invalid tokens - [  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \[.'):
			self.eqn.comp('x + [1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_10(self):
		"""Test acalc compile comp invalid tokens - ]  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: \].'):
			self.eqn.comp('x + ]1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_11(self):
		"""Test acalc compile comp invalid tokens - {  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: {.'):
			self.eqn.comp('x + {1', 'x', ())


	########################################################
	def test_compile_invalid_tokens_arrayclass_12(self):
		"""Test acalc compile comp invalid tokens - }  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'invalid tokens in ACalc compile: }.'):
			self.eqn.comp('x + }1', 'x', ())


	########################################################
	def test_compile_invalid_syntax_arrayclass_01(self):
		"""Test acalc compile comp invalid syntax in equation - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(SyntaxError, 'invalid syntax in equation in ACalc compile in position 9  x \* x \+ \.if\(x\)\.'):
			self.eqn.comp('x * x + .if(x)', 'x', ())


	########################################################
	def test_compile_unsupported_element_arrayclass_01(self):
		"""Test acalc compile comp unsupported element  - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported element in equation in ACalc compile.'):
			self.eqn.comp('x if x else not x', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_01(self):
		"""Test acalc compile comp unsupported function call (built ins) - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_02(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('math.invalidfunc(x)', 'x', ())


	########################################################
	def test_compile_unsupported_functioncall_arrayclass_03(self):
		"""Test acalc compile comp unsupported function call (math library) - Array code %(typelabel)s.
		"""
		with self.assertRaisesRegex(ValueError, 'unsupported function call in equation in ACalc compile.'):
			self.eqn.comp('invalidlib.sin(x)', 'x', ())



##############################################################################

'''


# ==============================================================================

# The basic template for testing each array type for _CheckParamKeywords.
calc_comp__CheckParamKeywords_template = '''
##############################################################################
class acalcccomp_calc_comp__CheckParamKeywords_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckParamKeywords_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckParamKeywords_00(self):
		"""Test acalc compile _CheckParamKeywords - 'x', [] - Array variable only  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', [])

		self.assertEqual(result, set([]))

	########################################################
	def test_compile__CheckParamKeywords_01(self):
		"""Test acalc compile _CheckParamKeywords - 'x', ['y'] - Array and one additional variable  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['y'])

		self.assertEqual(result, set([]))


	########################################################
	def test_compile__CheckParamKeywords_02(self):
		"""Test acalc compile _CheckParamKeywords - 'x', ['y', 'z'] - Array and two additional variables  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['y', 'z'])

		self.assertEqual(result, set([]))


	########################################################
	def test_compile__CheckParamKeywords_03(self):
		"""Test acalc compile _CheckParamKeywords - 'xtest', ['ytest', 'ztest'] - Long variable names  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('xtest', ['ytest', 'ztest'])

		self.assertEqual(result, set([]))


	########################################################
	def test_compile__CheckParamKeywords_04(self):
		"""Test acalc compile _CheckParamKeywords - 'abs', ['y', 'z'] - abs as array variable name  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('abs', ['y', 'z'])

		self.assertEqual(result, set(['abs']))


	########################################################
	def test_compile__CheckParamKeywords_05(self):
		"""Test acalc compile _CheckParamKeywords - 'math', ['y', 'z'] - math as array variable name  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('math', ['y', 'z'])

		self.assertEqual(result, set(['math']))


	########################################################
	def test_compile__CheckParamKeywords_06(self):
		"""Test acalc compile _CheckParamKeywords - 'x', ['abs', 'z'] - abs as additional variable name  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['abs', 'z'])

		self.assertEqual(result, set(['abs']))


	########################################################
	def test_compile__CheckParamKeywords_07(self):
		"""Test acalc compile _CheckParamKeywords - 'x', ['math', 'z'] - math as additional variable name  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['math', 'z'])

		self.assertEqual(result, set(['math']))


	########################################################
	def test_compile__CheckParamKeywords_08(self):
		"""Test acalc compile _CheckParamKeywords - 'abs', ['math', 'z'] - both as variable names  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('abs', ['math', 'z'])

		self.assertEqual(result, set(['abs', 'math']))


	########################################################
	def test_compile__CheckParamKeywords_09(self):
		"""Test acalc compile _CheckParamKeywords - 'x', ['math', 'abs'] - both as variable names  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['math', 'abs'])

		self.assertEqual(result, set(['abs', 'math']))


	########################################################
	def test_compile__CheckParamKeywords_10(self):
		"""Test acalc compile _CheckParamKeywords - 'if', [] - if as array variable  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('if', [])

		self.assertEqual(result, set(['if']))


	########################################################
	def test_compile__CheckParamKeywords_11(self):
		"""Test acalc compile _CheckParamKeywords - 'if', [] - if as additional variable  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('x', ['if'])

		self.assertEqual(result, set(['if']))


	########################################################
	def test_compile__CheckParamKeywords_12(self):
		"""Test acalc compile _CheckParamKeywords - 'if', ['def'] - if as array and def as additional variables  - Array code %(typelabel)s.
		"""
		result = self.eqn._CheckParamKeywords('if', ['def'])

		self.assertEqual(result, set(['if', 'def']))



##############################################################################

'''



# ==============================================================================


# The basic template for testing each array type for _FilterUSubConst.
calc_comp__FilterUSubConst_template = '''
##############################################################################
class acalcccomp_calc_comp__FilterUSubConst_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__FilterUSubConst_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__FilterUSubConst_00(self):
		"""Test acalc compile _FilterUSubConst - x + 1 - there should be no change  - Array code %(typelabel)s.
		"""
		# x + 1
		nodedata = [('pushconst', 1, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_01(self):
		"""Test acalc compile _FilterUSubConst - x + -1 - Array code %(typelabel)s.
		"""
		# x + -1
		nodedata = [('pushconst', 1, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_02(self):
		"""Test acalc compile _FilterUSubConst - x + +1 - Array code %(typelabel)s.
		"""
		# x + +1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_03(self):
		"""Test acalc compile _FilterUSubConst - x + -+1 - Array code %(typelabel)s.
		"""
		# x + -+1
		nodedata = [('pushconst', 1, False), ('uadd', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_04(self):
		"""Test acalc compile _FilterUSubConst - x + --1 - Array code %(typelabel)s.
		"""
		# x + --1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 2)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_05(self):
		"""Test acalc compile _FilterUSubConst - x + ---1 - Array code %(typelabel)s.
		"""
		# x + ---1
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('usub', None, False), 
				('usub', None, False), ('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_06(self):
		"""Test acalc compile _FilterUSubConst - x + -+-1 + 2 - Array code %(typelabel)s.
		"""
		# x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False), 
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False), 
				('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_07(self):
		"""Test acalc compile _FilterUSubConst - 3 * x + -+-1 + 2 - Array code %(typelabel)s.
		"""
		# 3 * x + -+-1 + 2
		nodedata = [('pushconst', 2, False), ('pushconst', 1, False), ('usub', None, False),
				('uadd', None, False), ('usub', None, False), ('pusharray', 'x', False),
				('pushconst', 3, False), ('mult', None, False), ('add', None, False),
				('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 3)
		resulttext = [(x.opcode, x.param, x.iscall) for x in result]
		self.assertEqual(resulttext, expected)


	########################################################
	def test_compile__FilterUSubConst_08(self):
		"""Test acalc compile _FilterUSubConst - x + abs(-1) - Array code %(typelabel)s.
		"""
		# x + abs(-1)
		nodedata = [('pushconst', 1, False), ('usub', None, False), ('abs', None, True), 
				('pusharray', 'x', False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)
		expected = [x for x in nodedata if x[0] not in ('usub', 'uadd')]

		result = self.eqn._FilterUSubConst(nodelist)

		self.assertEqual(len(result), nodelength - 1)
		resulttext = list(map(lambda x: (x.opcode, -x.param, x.iscall) if x.opcode == 'pushconst' else (x.opcode, x.param, x.iscall), result))
		self.assertEqual(resulttext, expected)


##############################################################################

'''

# ==============================================================================



# The basic template for testing each array type for _CheckOpCodes for built in functions.
calc_comp__CheckOpCodes_built_in_func_template = '''
##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_built_in_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_built_in_func_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_built_in_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_01(self):
		"""Test acalc compile _CheckOpCodes - abs(x) - Array code %(typelabel)s.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x)  - Array code %(typelabel)s.
		"""
		nodedata = [('pusharray', 'x', False), ('abs', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_03(self):
		"""Test acalc compile _CheckOpCodes - abs(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + abs(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('abs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_built_in_05(self):
		"""Test acalc compile _CheckOpCodes with invalid built in function name - 1 + invalidabs(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidabs', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidabs.'):
			self.eqn._CheckOpCodes(nodelist)



##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for _CheckOpCodes with module functions for floating point.
calc_comp__CheckOpCodes_module_func_float_template = '''
##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_func_float_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_float_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_func_float_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_01(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) - Array code %(typelabel)s.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x)  - Array code %(typelabel)s.
		"""
		nodedata = [('pusharray', 'x', False), ('math.sin', None, True), 
			('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_03(self):
		"""Test acalc compile _CheckOpCodes - math.sin(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.sin(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_func_float_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.sin(x) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('invalidmath.sin', None, True), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.sin.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################

'''



# ==============================================================================


# The basic template for testing each array type for _CheckOpCodes with module functions for integer.
calc_comp__CheckOpCodes_module_func_int_template = '''
##############################################################################
class acalcccomp_calc_comp__CheckOpCodes_module_func_int_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckOpCodes_module_func_int_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_00(self):
		"""Test acalc compile _CheckOpCodes - this should pass without a function call  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_01(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), ('math.factorial', None, True)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_02(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2)  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pusharray', 'x', False), 
			('math.factorial', None, True), ('pushconst', 1, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_03(self):
		"""Test acalc compile _CheckOpCodes - math.factorial(x, 2) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_04(self):
		"""Test acalc compile _CheckOpCodes - 1 + math.factorial(x, 2) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('math.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		self.eqn._CheckOpCodes(nodelist)


	########################################################
	def test_compile__CheckOpCodes_module_func_int_05(self):
		"""Test acalc compile _CheckOpCodes with invalid module function name - 1 + math.factorial(x, 2) + 2  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2, False), ('pushconst', 2, False), 
			('pusharray', 'x', False), ('invalidmath.factorial', None, True), 
			('pushconst', 1, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]
		nodelength = len(nodelist)

		with self.assertRaisesRegex(ValueError, 'invalid operations in ACalc compile: invalidmath.factorial.'):
			self.eqn._CheckOpCodes(nodelist)


##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for _ConvertConstants for convert constants.
calc_comp__ConvertConstants_convert_const_template = '''
##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_convert_const_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_00(self):
		"""Test acalc compile _ConvertConstants - convert constant from same type  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2%(sametype)s, False), ('pusharray', 'x', False), 
			('pushconst', 1%(sametype)s, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)


		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), %(expectedtype)s)
		self.assertIs(type(result[2].param), %(expectedtype)s)


	########################################################
	def test_compile__ConvertConstants_convert_const_01(self):
		"""Test acalc compile _ConvertConstants - convert constant from different type  - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2%(difftype)s, False), ('pusharray', 'x', False), 
			('pushconst', 1%(difftype)s, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		result = self.eqn._ConvertConstants(nodelist)

		self.assertEqual(result[0].opcode, 'pushconst')
		self.assertEqual(result[2].opcode, 'pushconst')

		self.assertIs(type(result[0].param), %(expectedtype)s)
		self.assertIs(type(result[2].param), %(expectedtype)s)


##############################################################################

'''


# ==============================================================================


# The basic template for testing integer constant conversions for calc compile function.
calc_comp__ConvertConstants_int_const_limits_template = '''
##############################################################################
class acalcccomp_calc_comp__ConvertConstants_convert_const_limit_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__ConvertConstants_int_const_limits_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_00(self):
		"""Test acalc compile _ConvertConstants convert int constant max  - Array code %(typelabel)s.
		"""
		MaxLimit = arrayfunc.arraylimits.%(typecode)s_max

		# This should pass.
		self.eqn.comp('x + ' + str(MaxLimit), 'x', ())

		# This is expected to fail.
		MaxLimit += 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MaxLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MaxLimit), 'x', ())


	########################################################
	def test_compile__ConvertConstants_convert_const_limit_01(self):
		"""Test acalc compile _ConvertConstants convert int constant min  - Array code %(typelabel)s.
		"""
		MinLimit = arrayfunc.arraylimits.%(typecode)s_min

		# This should pass.
		self.eqn.comp('x + ' + str(MinLimit), 'x', ())

		# This is expected to fail.
		MinLimit -= 1
		with self.assertRaisesRegex(OverflowError, 'equation constant ' + str(MinLimit) + ' is out of range for the selected array type in ACalc compile.'):
			self.eqn.comp('x + ' + str(MinLimit), 'x', ())



##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for _CheckStack.
calc_comp__CheckStack_template = '''
##############################################################################
class acalcccomp_calc_comp__CheckStack_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CheckStack_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CheckStack_00(self):
		"""Test acalc compile _CheckStack, stack OK - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2%(decimals)s, False), ('pusharray', 'x', False), 
			('pushconst', 1%(decimals)s, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertTrue(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_01(self):
		"""Test acalc compile _CheckStack stack underflow - Array code %(typelabel)s.
		"""
		nodedata = [('pushconst', 2%(decimals)s, False), ('pusharray', 'x', False), 
			('pushconst', 1%(decimals)s, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 5)


	########################################################
	def test_compile__CheckStack_02(self):
		"""Test acalc compile _CheckStack stack underflow and minimal stack - Array code %(typelabel)s.
		"""
		nodedata = [('add', None, False), ('add', None, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

		stackok, stackdepth = self.eqn._CheckStack(nodelist)

		self.assertFalse(stackok)
		self.assertEqual(stackdepth, 1)


##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for _AssignToRegisters.
calc_comp__AssignToRegisters_template = '''
##############################################################################
class acalcccomp_calc_comp__AssignToRegisters_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__AssignToRegisters_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__AssignToRegisters_00(self):
		"""Test acalc compile _AssignToRegisters, stack OK - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z'])

		resultdata = [(x.opcode, x.param, x.iscall) for x in resultlist]

		self.assertEqual(resultdata, expecteddata)
		self.assertEqual(paramorder, {'y': 0, 'z': 1})


	########################################################
	def test_compile__AssignToRegisters_01(self):
		"""Test acalc compile _AssignToRegisters, missing variable - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]


		with self.assertRaisesRegex(ValueError, 'undefined variables in ACalc compile: z.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y'])


	########################################################
	def test_compile__AssignToRegisters_02(self):
		"""Test acalc compile _AssignToRegisters, unused variable - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'unused variables in ACalc compile: w.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'w'])


	########################################################
	def test_compile__AssignToRegisters_03(self):
		"""Test acalc compile _AssignToRegisters, array name used in additonal parameters - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'array name used in additional parameters in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'x'])


	########################################################
	def test_compile__AssignToRegisters_04(self):
		"""Test acalc compile _AssignToRegisters, duplicate parameter names - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 'z', False), ('pushvar', 'y', False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]

 
		expecteddata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]
 

		with self.assertRaisesRegex(ValueError, 'duplicate parameter names in ACalc compile.'):
			resultlist, paramorder = self.eqn._AssignToRegisters(nodelist, 'x', ['y', 'z', 'y'])



##############################################################################

'''


# ==============================================================================


# The basic template for testing each array type for _CompileToByteCode.
calc_comp__CompileToByteCode_template = '''
##############################################################################
class acalcccomp_calc_comp__CompileToByteCode_%(typelabel)s(unittest.TestCase):
	"""Test for basic class compile.
	"""
	# Template: calc_comp__CompileToByteCode_template


	########################################################
	def setUp(self):
		"""Initialise.
		"""
		# The unit test code is auto-generated by a script, so we evaluate
		# the array type code to decide in each instance whether to use
		# an exact or approximate compare of the results. The following array 
		# type code is inserted by the script.
		self.TypeCode = '%(typecode)s'
		self.DataLen = 1000

		self.data = array.array(self.TypeCode, [1, 2, 3, 4, 5] * self.DataLen)
		%(bytesconverterdata)s
		self.dataout = array.array(self.TypeCode, [0] * len(self.data))
		%(bytesconverterdataout)s
		self.eqn = arrayfunc.acalc.calc(self.data, self.dataout)


	########################################################
	def test_compile__CompileToByteCode_00(self):
		"""Test acalc compile _CompileToByteCode, stack OK - Array code %(typelabel)s.
		"""
		nodedata = [('pushvar', 1, False), ('pushvar', 0, False), ('pushconst', 3, False), 
			('pusharray', 'x', False), ('pushconst', 1, False), ('add', None, False), 
			('add', None, False), ('add', None, False), ('add', None, False)]

		nodelist = [arrayfunc.acalc.OpCodeContainer(x, y, z)  for x, y, z in nodedata]


		codearray, varoffsetarray, constarray = self.eqn._CompileToByteCode(nodelist)

		expectedcode = array.array('I', [2, 2, 3, 1, 3, 4, 4, 4, 4])
		expectedvaroffset = array.array('I', [1, 0, 0, 0, 0, 0, 0, 0, 0])
		expectedconst = array.array(self.TypeCode, [0, 0, 3, 0, 1, 0, 0, 0, 0])

		self.assertEqual(codearray, expectedcode)
		self.assertEqual(varoffsetarray, expectedvaroffset)
		self.assertEqual(constarray, expectedconst)



##############################################################################

'''

# ==============================================================================


endtemplate = """
##############################################################################
if __name__ == '__main__':
    unittest.main()

##############################################################################
"""

# ==============================================================================


# Data for the copyright header files.
headerdate = codegen_common.FormatHeaderData('test_acalc', '12-Jan-2016', 'acalc')

# This is used for array types which are not bytes data.
notbytesdata = {'bytesconverterdata' : '', 'bytesconverterdataout' : ''}
# This is used for array types which are bytes data.
isbytesdata = {'bytesconverterdata' : bytesconverterdata, 'bytesconverterdataout' : bytesconverterdataout}


with open('test_acalc.py', 'w') as f:
	# The copyright header.
	f.write(codegen_common.HeaderTemplate % headerdate)


	####################################################################

	# Calc initialisation test.
	# Output the generated code for signed integer array types.
	for funtypes in codegen_common.signedint:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'typeclass' : 'int'}
		datarec.update(notbytesdata)
		f.write(calc_init_template % datarec)

	# Output the generated code for unsigned integer array types.
	for funtypes in codegen_common.unsignedint:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'typeclass' : 'uint'}
		datarec.update(notbytesdata)
		f.write(calc_init_template % datarec)

	# Output the generated code for float array types.
	for funtypes in codegen_common.floatarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'typeclass' : 'float'}
		datarec.update(notbytesdata)
		f.write(calc_init_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B', 'typeclass' : 'uint'}
	datarec.update(isbytesdata)
	f.write(calc_init_template % datarec)

	# Check for array type mismatch. We first create all possible combinations of array types.
	f.write(calc_init_mismatch_template)
	bytesconvert = {'bytesconverterdata' : bytesconverterdata, 'bytesconverterdataout' : bytesconverterdataout}
	for funtypesin, funtypesout in [(x,y) for x,y in itertools.product(codegen_common.arraycodes, codegen_common.arraycodes) if x != y]:
		datarec = {'typelabel1' : funtypesin, 'typecode1' : funtypesin, 'typelabel2' : funtypesout, 'typecode2' : funtypesout}
		datarec.update(notbytesdata)
		f.write(calc_init_mismatch_1_template % datarec)


	# Handle bytes in the input array.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel1' : 'bytes', 'typecode1' : 'B', 'typelabel2' : funtypes, 'typecode2' : funtypes}
		datarec.update({'bytesconverterdata' : bytesconverterdata, 'bytesconverterdataout' : ''})
		f.write(calc_init_mismatch_1_template % datarec)

	# Handle bytes in the output array.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel1' : funtypes, 'typecode1' : funtypes, 'typelabel2' : 'bytes', 'typecode2' : 'B'}
		datarec.update({'bytesconverterdata' : '', 'bytesconverterdataout' : bytesconverterdataout})
		f.write(calc_init_mismatch_1_template % datarec)



	f.write(calc_init_mismatch_2_template)

	####################################################################

	# Calc._FindUnsupportedPlatforms tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_init_platform_math_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_init_platform_math_template % datarec)


	####################################################################

	# Calc._CheckParamKeywords tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckParamKeywords_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__CheckParamKeywords_template % datarec)


	####################################################################

	# Calc.comp tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp_template % datarec)


	####################################################################


	# Calc class _FilterUSubConst function tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__FilterUSubConst_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__FilterUSubConst_template % datarec)


	####################################################################

	# Calc class _CheckOpCodes function tests.

	# Output the generated code for built in functions.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckOpCodes_built_in_func_template % datarec)


	# Output the generated code for integer array types.
	for funtypes in codegen_common.intarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckOpCodes_module_func_int_template % datarec)


	# Output the generated code for float array types.
	for funtypes in codegen_common.floatarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckOpCodes_module_func_float_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__CheckOpCodes_built_in_func_template % datarec)


	####################################################################

	# Output the generated code for integer array types for type conversion tests.
	for funtypes in codegen_common.intarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'sametype' : '', 'difftype' : '.0', 'expectedtype' : 'int'}
		datarec.update(notbytesdata)
		f.write(calc_comp__ConvertConstants_convert_const_template % datarec)


	# Output the generated code for float array types for type conversion tests.
	for funtypes in codegen_common.floatarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'sametype' : '.0', 'difftype' : '', 'expectedtype' : 'float'}
		datarec.update(notbytesdata)
		f.write(calc_comp__ConvertConstants_convert_const_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B', 'sametype' : '', 'difftype' : '.0', 'expectedtype' : 'int'}
	datarec.update(isbytesdata)
	f.write(calc_comp__ConvertConstants_convert_const_template % datarec)


	####################################################################


	# Output the generated code integer constant conversions tests.
	for funtypes in codegen_common.intarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__ConvertConstants_int_const_limits_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__ConvertConstants_int_const_limits_template % datarec)


	####################################################################


	# Calc class _CheckStack function tests.
	# Output the generated code for integer array types.
	for funtypes in codegen_common.intarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'decimals' : ''}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckStack_template % datarec)


	# Output the generated code for float array types.
	for funtypes in codegen_common.floatarrays:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes, 'decimals' : '.0'}
		datarec.update(notbytesdata)
		f.write(calc_comp__CheckStack_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B', 'decimals' : ''}
	datarec.update(isbytesdata)
	f.write(calc_comp__CheckStack_template % datarec)


	####################################################################


	# Calc class _AssignToRegisters function tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__AssignToRegisters_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__AssignToRegisters_template % datarec)



	####################################################################


	# Calc class _CompileToByteCode function tests.
	# Output the generated code for all array types.
	for funtypes in codegen_common.arraycodes:
		datarec = {'typelabel' : funtypes, 'typecode' : funtypes}
		datarec.update(notbytesdata)
		f.write(calc_comp__CompileToByteCode_template % datarec)


	# Output the generated code for bytes data types.
	datarec = {'typelabel' : 'bytes', 'typecode' : 'B'}
	datarec.update(isbytesdata)
	f.write(calc_comp__CompileToByteCode_template % datarec)


	####################################################################


	f.write(endtemplate)

