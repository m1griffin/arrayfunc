#!/usr/bin/env python3
##############################################################################
# Project:  arrayfunc
# Module:   test_amap3.py
# Purpose:  arrayfunc unit test.
# Language: Python 3.4
# Date:     23-May-2014.
# Ver:      24-Sep-2017.
#
###############################################################################
#
#   Copyright 2014 - 2017    Michael Griffin    <m12.griffin@gmail.com>
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
##############################################################################
"""This conducts unit tests for amap and amapi.
"""

##############################################################################
import array
import itertools
import math
import operator
import platform

import unittest

import arrayfunc

##############################################################################

##############################################################################

# The following code is all auto-generated.



##############################################################################
class amap_nan_data_af_add_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout, -25.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan, -25.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout, -25.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf, -25.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout, -25.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf, -25.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  -1.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  -1.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  0.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  0.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  1.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  1.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  25.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  25.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  25.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  25.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  25.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  25.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan, -2.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf, -2.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  2.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  2.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout, -100.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan, -100.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  100.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  100.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan, -2.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf, -2.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout, -2.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf, -2.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout, -2.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf, -2.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  -1.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  -1.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  -1.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  -1.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  -1.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  -1.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  1.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  1.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  1.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  1.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  1.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  1.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  2.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  2.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  2.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  2.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  2.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  2.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout, -100.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan, -100.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  100.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  100.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  100.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan, -2.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf, -2.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  1.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  1.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  2.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  2.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan, -2.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf, -2.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  0.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  1.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  2.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  2.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout, -3.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan, -3.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout, -3.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf, -3.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout, -3.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf, -3.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -2.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -2.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -2.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -2.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -2.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -2.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  0.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  0.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  1.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  1.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_5_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  2.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  2.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_6_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  3.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  3.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  3.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  3.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  3.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  3.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_neg_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_neg_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.datanan, self.dataout)


	########################################################
	def test_nan_af_neg_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.datanan)


	########################################################
	def test_nan_af_neg_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_neg_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_neg_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.datainf, self.dataout)


	########################################################
	def test_inf_af_neg_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.datainf)


	########################################################
	def test_inf_af_neg_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_neg_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_neg_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.dataninf, self.dataout)


	########################################################
	def test_ninf_af_neg_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.dataninf)


	########################################################
	def test_ninf_af_neg_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_neg_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan, -2.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf, -2.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  -1.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  -1.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  0.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  0.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  1.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  1.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  2.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  2.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, -20.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, -20.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, -20.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, -20.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, -20.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, -20.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -10.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -10.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -10.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -10.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -10.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -10.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 10.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 10.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 10.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 10.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 10.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 10.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 12.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 12.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 12.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 12.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 12.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 12.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_5_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 14.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 14.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 14.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 14.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 14.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 14.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_6_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 16.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 16.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 16.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 16.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 16.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 16.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_7_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 18.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 18.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 18.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 18.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 18.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 18.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_abs_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_af_abs_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datanan, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datanan)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_abs_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_abs_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_acos_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acos_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.datanan, self.dataout)


	########################################################
	def test_nan_math_acos_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.datanan)


	########################################################
	def test_nan_math_acos_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_acos_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acos_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.datainf, self.dataout)


	########################################################
	def test_inf_math_acos_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.datainf)


	########################################################
	def test_inf_math_acos_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_acos_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_acos_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_acos_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.dataninf)


	########################################################
	def test_ninf_math_acos_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_acos_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_acosh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acosh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_acosh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datanan)


	########################################################
	def test_nan_math_acosh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_acosh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acosh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_acosh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datainf)


	########################################################
	def test_inf_math_acosh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_acosh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_acosh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_acosh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.dataninf)


	########################################################
	def test_ninf_math_acosh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_acosh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_asin_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asin_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.datanan, self.dataout)


	########################################################
	def test_nan_math_asin_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.datanan)


	########################################################
	def test_nan_math_asin_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_asin_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asin_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.datainf, self.dataout)


	########################################################
	def test_inf_math_asin_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.datainf)


	########################################################
	def test_inf_math_asin_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_asin_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_asin_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_asin_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.dataninf)


	########################################################
	def test_ninf_math_asin_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_asin_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_asinh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asinh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_asinh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datanan)


	########################################################
	def test_nan_math_asinh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_asinh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asinh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_asinh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datainf)


	########################################################
	def test_inf_math_asinh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_asinh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_asinh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_asinh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.dataninf)


	########################################################
	def test_ninf_math_asinh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_asinh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan, self.datanan, self.dataout)


	########################################################
	def test_nan_math_atan_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan, self.datanan)


	########################################################
	def test_nan_math_atan_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan, -2.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  -1.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  0.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  1.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  2.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  2.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atanh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atanh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_atanh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datanan)


	########################################################
	def test_nan_math_atanh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atanh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atanh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_atanh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datainf)


	########################################################
	def test_inf_math_atanh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_atanh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_atanh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_atanh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.dataninf)


	########################################################
	def test_ninf_math_atanh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_atanh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_ceil_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ceil_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.datanan, self.dataout)


	########################################################
	def test_nan_math_ceil_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datanan)


	########################################################
	def test_nan_math_ceil_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_ceil_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_ceil_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.datainf, self.dataout)


	########################################################
	def test_inf_math_ceil_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datainf)


	########################################################
	def test_inf_math_ceil_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_ceil_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_ceil_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_ceil_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.dataninf)


	########################################################
	def test_ninf_math_ceil_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_ceil_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout, -3.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan, -3.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout, -3.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf, -3.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout, -3.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf, -3.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  -1.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  -1.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  0.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  0.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  1.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  1.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  3.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  3.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  3.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  3.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  3.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  3.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_cos_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cos_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.datanan, self.dataout)


	########################################################
	def test_nan_math_cos_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.datanan)


	########################################################
	def test_nan_math_cos_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_cos_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cos_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.datainf, self.dataout)


	########################################################
	def test_inf_math_cos_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.datainf)


	########################################################
	def test_inf_math_cos_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_cos_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_cos_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_cos_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.dataninf)


	########################################################
	def test_ninf_math_cos_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_cos_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_cosh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cosh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_cosh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datanan)


	########################################################
	def test_nan_math_cosh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_cosh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cosh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_cosh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datainf)


	########################################################
	def test_inf_math_cosh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_cosh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_cosh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_cosh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.dataninf)


	########################################################
	def test_ninf_math_cosh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_cosh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_degrees_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_degrees_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.datanan, self.dataout)


	########################################################
	def test_nan_math_degrees_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datanan)


	########################################################
	def test_nan_math_degrees_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_degrees_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_degrees_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.datainf, self.dataout)


	########################################################
	def test_inf_math_degrees_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datainf)


	########################################################
	def test_inf_math_degrees_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_degrees_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_degrees_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_degrees_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.dataninf)


	########################################################
	def test_ninf_math_degrees_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_degrees_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_erf_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erf_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_erf, self.datanan, self.dataout)


	########################################################
	def test_nan_math_erf_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_erf, self.datanan)


	########################################################
	def test_nan_math_erf_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_erf_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erf_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erf_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_erfc_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erfc_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_erfc, self.datanan, self.dataout)


	########################################################
	def test_nan_math_erfc_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datanan)


	########################################################
	def test_nan_math_erfc_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_erfc_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erfc_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erfc_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_exp_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_exp_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_exp, self.datanan, self.dataout)


	########################################################
	def test_nan_math_exp_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_exp, self.datanan)


	########################################################
	def test_nan_math_exp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_exp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_exp_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_exp, self.datainf, self.dataout)


	########################################################
	def test_inf_math_exp_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_exp, self.datainf)


	########################################################
	def test_inf_math_exp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_exp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_exp_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_expm1_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_expm1_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_expm1, self.datanan, self.dataout)


	########################################################
	def test_nan_math_expm1_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datanan)


	########################################################
	def test_nan_math_expm1_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_expm1_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_expm1_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_expm1, self.datainf, self.dataout)


	########################################################
	def test_inf_math_expm1_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datainf)


	########################################################
	def test_inf_math_expm1_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_expm1_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_expm1_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fabs_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fabs_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.datanan, self.dataout)


	########################################################
	def test_nan_math_fabs_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datanan)


	########################################################
	def test_nan_math_fabs_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fabs_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fabs_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.datainf, self.dataout)


	########################################################
	def test_inf_math_fabs_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datainf)


	########################################################
	def test_inf_math_fabs_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fabs_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fabs_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_fabs_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.dataninf)


	########################################################
	def test_ninf_math_fabs_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fabs_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_floor_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_floor_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.datanan, self.dataout)


	########################################################
	def test_nan_math_floor_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.datanan)


	########################################################
	def test_nan_math_floor_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_floor_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_floor_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.datainf, self.dataout)


	########################################################
	def test_inf_math_floor_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.datainf)


	########################################################
	def test_inf_math_floor_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_floor_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_floor_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_floor_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.dataninf)


	########################################################
	def test_ninf_math_floor_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_floor_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [100.0] * 10)
		self.dataok = array.array('f', [100.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_gamma_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_gamma_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.datanan, self.dataout)


	########################################################
	def test_nan_math_gamma_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datanan)


	########################################################
	def test_nan_math_gamma_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_gamma_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_gamma_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.datainf, self.dataout)


	########################################################
	def test_inf_math_gamma_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datainf)


	########################################################
	def test_inf_math_gamma_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_gamma_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_gamma_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_gamma_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.dataninf)


	########################################################
	def test_ninf_math_gamma_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_gamma_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan, -2.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf, -2.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  -1.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  -1.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  0.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  0.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  1.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  1.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  2.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  2.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  0.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_isinf_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_isinf_amap(self):
		"""Test amap for math_isinf with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datanan, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isinf_amapi(self):
		"""Test amapi for math_isinf with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datanan)

		self.assertEqual(list(self.datanan), expected)


	########################################################
	def test_nan_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datanan, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datanan, disovfl=True)

		self.assertEqual(list(self.datanan), expected)



	########################################################
	def test_inf_math_isinf_amap(self):
		"""Test amap for math_isinf with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datainf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isinf_amapi(self):
		"""Test amapi for math_isinf with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datainf)

		self.assertEqual(list(self.datainf), expected)


	########################################################
	def test_inf_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datainf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datainf, disovfl=True)

		self.assertEqual(list(self.datainf), expected)



	########################################################
	def test_ninf_math_isinf_amap(self):
		"""Test amap for math_isinf with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.dataninf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isinf_amapi(self):
		"""Test amapi for math_isinf with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.dataninf)

		self.assertEqual(list(self.dataninf), expected)


	########################################################
	def test_ninf_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.dataninf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.dataninf, disovfl=True)

		self.assertEqual(list(self.dataninf), expected)


##############################################################################

##############################################################################
class amap_nan_data_math_isnan_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_isnan_amap(self):
		"""Test amap for math_isnan with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datanan, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isnan_amapi(self):
		"""Test amapi for math_isnan with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datanan)

		self.assertEqual(list(self.datanan), expected)


	########################################################
	def test_nan_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datanan, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with nan - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datanan, disovfl=True)

		self.assertEqual(list(self.datanan), expected)



	########################################################
	def test_inf_math_isnan_amap(self):
		"""Test amap for math_isnan with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datainf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isnan_amapi(self):
		"""Test amapi for math_isnan with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datainf)

		self.assertEqual(list(self.datainf), expected)


	########################################################
	def test_inf_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datainf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datainf, disovfl=True)

		self.assertEqual(list(self.datainf), expected)



	########################################################
	def test_ninf_math_isnan_amap(self):
		"""Test amap for math_isnan with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.dataninf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isnan_amapi(self):
		"""Test amapi for math_isnan with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.dataninf)

		self.assertEqual(list(self.dataninf), expected)


	########################################################
	def test_ninf_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.dataninf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with -inf - Array code f.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.dataninf, disovfl=True)

		self.assertEqual(list(self.dataninf), expected)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan, -2.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf, -2.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  -1.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  -1.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  0.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  0.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  1.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  1.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  2.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  2.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_lgamma_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_lgamma_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datanan, self.dataout)


	########################################################
	def test_nan_math_lgamma_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datanan)


	########################################################
	def test_nan_math_lgamma_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_lgamma_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_lgamma_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datainf, self.dataout)


	########################################################
	def test_inf_math_lgamma_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datainf)


	########################################################
	def test_inf_math_lgamma_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_lgamma_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_lgamma_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_lgamma_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.dataninf)


	########################################################
	def test_ninf_math_lgamma_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_lgamma_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_log_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.datanan)


	########################################################
	def test_nan_math_log_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.datainf)


	########################################################
	def test_inf_math_log_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.dataninf)


	########################################################
	def test_ninf_math_log_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log10_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log10_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log10_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.datanan)


	########################################################
	def test_nan_math_log10_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log10_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log10_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log10_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.datainf)


	########################################################
	def test_inf_math_log10_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log10_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log10_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log10_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.dataninf)


	########################################################
	def test_ninf_math_log10_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log10_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log1p_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log1p_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log1p_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datanan)


	########################################################
	def test_nan_math_log1p_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log1p_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log1p_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log1p_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datainf)


	########################################################
	def test_inf_math_log1p_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log1p_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log1p_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log1p_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.dataninf)


	########################################################
	def test_ninf_math_log1p_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log1p_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log2_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [1.0] * 10)
		self.dataok = array.array('f', [1.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log2_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log2_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.datanan)


	########################################################
	def test_nan_math_log2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log2_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.datainf)


	########################################################
	def test_inf_math_log2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log2_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.dataninf)


	########################################################
	def test_ninf_math_log2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code f.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_radians_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_radians_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.datanan, self.dataout)


	########################################################
	def test_nan_math_radians_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.datanan)


	########################################################
	def test_nan_math_radians_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_radians_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_radians_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.datainf, self.dataout)


	########################################################
	def test_inf_math_radians_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.datainf)


	########################################################
	def test_inf_math_radians_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_radians_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_radians_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_radians_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.dataninf)


	########################################################
	def test_ninf_math_radians_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_radians_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_sin_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sin_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sin_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.datanan)


	########################################################
	def test_nan_math_sin_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sin_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sin_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sin_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.datainf)


	########################################################
	def test_inf_math_sin_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_sin_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_sin_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sin_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.dataninf)


	########################################################
	def test_ninf_math_sin_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_sin_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_sinh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sinh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sinh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datanan)


	########################################################
	def test_nan_math_sinh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sinh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sinh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sinh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datainf)


	########################################################
	def test_inf_math_sinh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_sinh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sinh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sinh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.dataninf)


	########################################################
	def test_ninf_math_sinh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_sinh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_sqrt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sqrt_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sqrt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datanan)


	########################################################
	def test_nan_math_sqrt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sqrt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sqrt_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sqrt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datainf)


	########################################################
	def test_inf_math_sqrt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_sqrt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sqrt_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sqrt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.dataninf)


	########################################################
	def test_ninf_math_sqrt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_sqrt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_tan_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tan_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.datanan, self.dataout)


	########################################################
	def test_nan_math_tan_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.datanan)


	########################################################
	def test_nan_math_tan_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_tan_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tan_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.datainf, self.dataout)


	########################################################
	def test_inf_math_tan_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.datainf)


	########################################################
	def test_inf_math_tan_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_tan_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_tan_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_tan_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.dataninf)


	########################################################
	def test_ninf_math_tan_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_tan_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_tanh_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tanh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tanh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_tanh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datanan)


	########################################################
	def test_nan_math_tanh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_tanh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tanh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_tanh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_trunc_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [0.0] * 10)
		self.dataok = array.array('f', [0.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_math_trunc_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.datanan, self.dataout)


	########################################################
	def test_nan_math_trunc_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datanan)


	########################################################
	def test_nan_math_trunc_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_trunc_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_trunc_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.datainf, self.dataout)


	########################################################
	def test_inf_math_trunc_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datainf)


	########################################################
	def test_inf_math_trunc_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_trunc_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_trunc_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_trunc_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code f.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.dataninf)


	########################################################
	def test_ninf_math_trunc_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_trunc_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code f.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_0_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_1_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_2_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_3_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_4_f(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('f', [-5.0] * 10)
		self.dataok = array.array('f', [-5.0] * 10)

		self.dataout = array.array('f', itertools.repeat(0.0, 10))

		self.datainf = array.array('f', [float('inf')] * 10)
		self.datanan = array.array('f', [float('nan')] * 10)
		self.dataninf = array.array('f', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code f.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout, -25.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan, -25.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout, -25.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf, -25.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout, -25.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok, -25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf, -25.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat(-25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf, -25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  -1.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  -1.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  0.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  0.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  1.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  1.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_add_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_add_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  25.0)


	########################################################
	def test_nan_af_add_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  25.0)


	########################################################
	def test_nan_af_add_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datanan, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_add_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datanan), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datanan,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_add_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  25.0)


	########################################################
	def test_inf_af_add_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  25.0)


	########################################################
	def test_inf_af_add_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.datainf, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_add_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.datainf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.datainf,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_add_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataok, self.dataout,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  25.0)


	########################################################
	def test_ninf_af_add_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataok,  25.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  25.0)


	########################################################
	def test_ninf_af_add_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_add, self.dataninf, self.dataout,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_add_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x + y for x,y in zip(list(self.dataninf), itertools.repeat( 25.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_add, self.dataninf,  25.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan, -2.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf, -2.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_div_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  2.0)


	########################################################
	def test_nan_af_div_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_div_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  2.0)


	########################################################
	def test_inf_af_div_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_div_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_div_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(x / y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout, -100.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan, -100.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_div_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_div_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataok, self.dataout,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  100.0)


	########################################################
	def test_nan_af_div_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataok,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  100.0)


	########################################################
	def test_nan_af_div_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datanan, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_div_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datanan,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_div_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.datainf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_div_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.datainf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.datainf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_div_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_div_r, self.dataninf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_div_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [(y / x) for x,y in zip(list(self.dataninf), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_div_r, self.dataninf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan, -2.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf, -2.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout, -2.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf, -2.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout, -2.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf, -2.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  -1.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  -1.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  -1.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  -1.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  -1.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  -1.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  1.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  1.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  1.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  1.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  1.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  1.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_floordiv_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  2.0)


	########################################################
	def test_nan_af_floordiv_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x // y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_floordiv_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  2.0)


	########################################################
	def test_inf_af_floordiv_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.datainf, self.dataout,  2.0, disovfl=True)


	########################################################
	def test_inf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.datainf,  2.0, disovfl=True)



	########################################################
	def test_ninf_af_floordiv_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_floordiv_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_floordiv_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv, self.dataninf, self.dataout,  2.0, disovfl=True)


	########################################################
	def test_ninf_af_floordiv_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv, self.dataninf,  2.0, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout, -100.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok, -100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan, -100.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat(-100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf, -100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf, -100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_floordiv_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_floordiv_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataok, self.dataout,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  100.0)


	########################################################
	def test_nan_af_floordiv_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataok,  100.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  100.0)


	########################################################
	def test_nan_af_floordiv_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datanan, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y // x for x,y in zip(list(self.datanan), itertools.repeat( 100.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datanan,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_floordiv_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.datainf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.datainf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_floordiv_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  100.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_floordiv_r, self.dataninf, self.dataout,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_floordiv_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  100.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = itertools.repeat(0.0)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_floordiv_r, self.dataninf,  100.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan, -2.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf, -2.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  1.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  1.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  2.0)


	########################################################
	def test_nan_af_mod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  2.0)


	########################################################
	def test_inf_af_mod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan, -2.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf, -2.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  0.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  1.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mod_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  2.0)


	########################################################
	def test_nan_af_mod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datanan)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  2.0)


	########################################################
	def test_inf_af_mod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.datainf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This is the actual test. We always expect NaN to raise errors.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mod_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		# All error conditions expect NaN.
		expected = [float('nan')] * len(self.dataninf)

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mod_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout, -3.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan, -3.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout, -3.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf, -3.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout, -3.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf, -3.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -2.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -2.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -2.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -2.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -2.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -2.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -1.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -1.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  0.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  0.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  1.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  1.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_5_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  2.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  2.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_mult_6_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_mult_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  3.0)


	########################################################
	def test_nan_af_mult_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  3.0)


	########################################################
	def test_nan_af_mult_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datanan, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_mult_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datanan,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_mult_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  3.0)


	########################################################
	def test_inf_af_mult_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  3.0)


	########################################################
	def test_inf_af_mult_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.datainf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_mult_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.datainf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_mult_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  3.0)


	########################################################
	def test_ninf_af_mult_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  3.0)


	########################################################
	def test_ninf_af_mult_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_mult, self.dataninf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_mult_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x * y for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_mult, self.dataninf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_neg_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_neg_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.datanan, self.dataout)


	########################################################
	def test_nan_af_neg_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.datanan)


	########################################################
	def test_nan_af_neg_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_neg_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_neg_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.datainf, self.dataout)


	########################################################
	def test_inf_af_neg_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.datainf)


	########################################################
	def test_inf_af_neg_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_neg_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_neg_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_neg, self.dataninf, self.dataout)


	########################################################
	def test_ninf_af_neg_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_neg, self.dataninf)


	########################################################
	def test_ninf_af_neg_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_neg, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_neg_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [-x for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_neg, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0)


	########################################################
	def test_nan_af_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0)


	########################################################
	def test_inf_af_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [x ** y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_pow_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0)


	########################################################
	def test_nan_af_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0)


	########################################################
	def test_inf_af_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_pow_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [y ** x for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_pow_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan, -2.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf, -2.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf, -2.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  -1.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  -1.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  0.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  0.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  0.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  1.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  1.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  1.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_af_sub_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  2.0)


	########################################################
	def test_nan_af_sub_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_af_sub_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  2.0)


	########################################################
	def test_inf_af_sub_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_af_sub_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  2.0)


	########################################################
	def test_ninf_af_sub_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [x - y for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, -20.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, -20.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, -20.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, -20.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, -20.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, -20.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, -20.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(-20.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, -20.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -10.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -10.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -10.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -10.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -10.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -10.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -1.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -1.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 10.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 10.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 10.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 10.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 10.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 10.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 10.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(10.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 10.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 12.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 12.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 12.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 12.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 12.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 12.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 12.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(12.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 12.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_5_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 14.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 14.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 14.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 14.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 14.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 14.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 14.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(14.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 14.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_6_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 16.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 16.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 16.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 16.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 16.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 16.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 16.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(16.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 16.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_sub_r_7_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_sub_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 18.0)


	########################################################
	def test_nan_af_sub_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 18.0)


	########################################################
	def test_nan_af_sub_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datanan, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_sub_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datanan), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datanan, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_sub_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 18.0)


	########################################################
	def test_inf_af_sub_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 18.0)


	########################################################
	def test_inf_af_sub_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.datainf, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.datainf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.datainf, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_sub_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataok, self.dataout, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 18.0)


	########################################################
	def test_ninf_af_sub_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataok, 18.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 18.0)


	########################################################
	def test_ninf_af_sub_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_sub_r, self.dataninf, self.dataout, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_sub_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [y - x for x,y in zip(list(self.dataninf), itertools.repeat(18.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_sub_r, self.dataninf, 18.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_eq_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_eq_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_eq_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_eq_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_eq_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_eq_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_eq, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_eq_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x == y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_eq, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gt_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x > y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_gte_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_gte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x >= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_gte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lt_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x < y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_lte_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_lte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x <= y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_lte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_ne_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_ne_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_ne_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_ne_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_ne_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_ne_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_ne, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_ne_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [x != y for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_ne, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_af_abs_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_af_abs_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datanan, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datanan)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_af_abs_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_af_abs_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_af_abs_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_af_abs_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.af_abs, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_af_abs_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [abs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.af_abs, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_acos_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acos_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.datanan, self.dataout)


	########################################################
	def test_nan_math_acos_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.datanan)


	########################################################
	def test_nan_math_acos_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_acos_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acos_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.datainf, self.dataout)


	########################################################
	def test_inf_math_acos_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.datainf)


	########################################################
	def test_inf_math_acos_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_acos_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_acos_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acos, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_acos_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acos, self.dataninf)


	########################################################
	def test_ninf_math_acos_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acos, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_acos_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acos, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_acosh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_acosh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_acosh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datanan)


	########################################################
	def test_nan_math_acosh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_acosh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_acosh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_acosh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datainf)


	########################################################
	def test_inf_math_acosh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_acosh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.acosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_acosh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_acosh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_acosh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_acosh, self.dataninf)


	########################################################
	def test_ninf_math_acosh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_acosh, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_acosh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_acosh, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_asin_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asin_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.datanan, self.dataout)


	########################################################
	def test_nan_math_asin_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.datanan)


	########################################################
	def test_nan_math_asin_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_asin_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asin_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.datainf, self.dataout)


	########################################################
	def test_inf_math_asin_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.datainf)


	########################################################
	def test_inf_math_asin_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_asin_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_asin_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asin, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_asin_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asin, self.dataninf)


	########################################################
	def test_ninf_math_asin_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asin, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_asin_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asin, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_asinh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_asinh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_asinh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datanan)


	########################################################
	def test_nan_math_asinh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_asinh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_asinh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_asinh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datainf)


	########################################################
	def test_inf_math_asinh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_asinh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_asinh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_asinh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_asinh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_asinh, self.dataninf)


	########################################################
	def test_ninf_math_asinh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_asinh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_asinh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.asinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_asinh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan, self.datanan, self.dataout)


	########################################################
	def test_nan_math_atan_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan, self.datanan)


	########################################################
	def test_nan_math_atan_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan, -2.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  -1.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  0.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  1.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_atan2_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  2.0)


	########################################################
	def test_nan_math_atan2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf, -2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atan2_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atan2_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_atan2_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_atan2_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atan2_r_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_atan2_r_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  2.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atan2_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_atan2_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  2.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atan2(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atan2_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_atanh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_atanh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_atanh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datanan)


	########################################################
	def test_nan_math_atanh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_atanh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.atanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_atanh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_atanh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datainf)


	########################################################
	def test_inf_math_atanh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_atanh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_atanh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_atanh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_atanh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_atanh, self.dataninf)


	########################################################
	def test_ninf_math_atanh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_atanh, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_atanh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_atanh, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_ceil_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ceil_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.datanan, self.dataout)


	########################################################
	def test_nan_math_ceil_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datanan)


	########################################################
	def test_nan_math_ceil_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_ceil_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_ceil_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.datainf, self.dataout)


	########################################################
	def test_inf_math_ceil_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datainf)


	########################################################
	def test_inf_math_ceil_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_ceil_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_ceil_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ceil, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_ceil_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ceil, self.dataninf)


	########################################################
	def test_ninf_math_ceil_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ceil, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_ceil_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ceil, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout, -3.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan, -3.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout, -3.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf, -3.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout, -3.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok, -3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf, -3.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf, -3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  -1.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  -1.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  0.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  0.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  1.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  1.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_copysign_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_copysign_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  3.0)


	########################################################
	def test_nan_math_copysign_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  3.0)


	########################################################
	def test_nan_math_copysign_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datanan, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_copysign_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datanan,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_copysign_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  3.0)


	########################################################
	def test_inf_math_copysign_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  3.0)


	########################################################
	def test_inf_math_copysign_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.datainf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_copysign_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.datainf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_copysign_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataok, self.dataout,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  3.0)


	########################################################
	def test_ninf_math_copysign_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataok,  3.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  3.0)


	########################################################
	def test_ninf_math_copysign_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_copysign, self.dataninf, self.dataout,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_copysign_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.copysign(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 3.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_copysign, self.dataninf,  3.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_cos_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cos_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.datanan, self.dataout)


	########################################################
	def test_nan_math_cos_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.datanan)


	########################################################
	def test_nan_math_cos_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_cos_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cos(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cos_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.datainf, self.dataout)


	########################################################
	def test_inf_math_cos_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.datainf)


	########################################################
	def test_inf_math_cos_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_cos_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_cos_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cos, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_cos_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cos, self.dataninf)


	########################################################
	def test_ninf_math_cos_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cos, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_cos_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cos, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_cosh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_cosh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_cosh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datanan)


	########################################################
	def test_nan_math_cosh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_cosh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_cosh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_cosh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datainf)


	########################################################
	def test_inf_math_cosh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_cosh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_cosh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_cosh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_cosh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_cosh, self.dataninf)


	########################################################
	def test_ninf_math_cosh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_cosh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_cosh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.cosh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_cosh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_degrees_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_degrees_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.datanan, self.dataout)


	########################################################
	def test_nan_math_degrees_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datanan)


	########################################################
	def test_nan_math_degrees_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_degrees_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_degrees_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.datainf, self.dataout)


	########################################################
	def test_inf_math_degrees_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datainf)


	########################################################
	def test_inf_math_degrees_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_degrees_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_degrees_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_degrees, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_degrees_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_degrees, self.dataninf)


	########################################################
	def test_ninf_math_degrees_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_degrees, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_degrees_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.degrees(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_degrees, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_erf_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erf_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_erf, self.datanan, self.dataout)


	########################################################
	def test_nan_math_erf_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_erf, self.datanan)


	########################################################
	def test_nan_math_erf_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_erf_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erf_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erf_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erf_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erf, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erf_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erf(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erf, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_erfc_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_erfc_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_erfc, self.datanan, self.dataout)


	########################################################
	def test_nan_math_erfc_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datanan)


	########################################################
	def test_nan_math_erfc_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_erfc_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_erfc_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_erfc_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_erfc_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_erfc, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_erfc_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.erfc(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_erfc, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_exp_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_exp_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_exp, self.datanan, self.dataout)


	########################################################
	def test_nan_math_exp_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_exp, self.datanan)


	########################################################
	def test_nan_math_exp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_exp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_exp_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_exp, self.datainf, self.dataout)


	########################################################
	def test_inf_math_exp_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_exp, self.datainf)


	########################################################
	def test_inf_math_exp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_exp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_exp_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_exp, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_exp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.exp(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_exp, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_expm1_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_expm1_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_expm1, self.datanan, self.dataout)


	########################################################
	def test_nan_math_expm1_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datanan)


	########################################################
	def test_nan_math_expm1_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_expm1_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_expm1_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_expm1, self.datainf, self.dataout)


	########################################################
	def test_inf_math_expm1_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datainf)


	########################################################
	def test_inf_math_expm1_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_expm1_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_expm1_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_expm1, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_expm1_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.expm1(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_expm1, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fabs_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fabs_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.datanan, self.dataout)


	########################################################
	def test_nan_math_fabs_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datanan)


	########################################################
	def test_nan_math_fabs_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fabs_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fabs_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.datainf, self.dataout)


	########################################################
	def test_inf_math_fabs_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datainf)


	########################################################
	def test_inf_math_fabs_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fabs_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fabs_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_fabs, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_fabs_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_fabs, self.dataninf)


	########################################################
	def test_ninf_math_fabs_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fabs, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fabs_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.fabs(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fabs, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_floor_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_floor_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.datanan, self.dataout)


	########################################################
	def test_nan_math_floor_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.datanan)


	########################################################
	def test_nan_math_floor_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_floor_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_floor_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.datainf, self.dataout)


	########################################################
	def test_inf_math_floor_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.datainf)


	########################################################
	def test_inf_math_floor_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_floor_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_floor_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_floor, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_floor_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_floor, self.dataninf)


	########################################################
	def test_ninf_math_floor_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_floor, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_floor_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_floor, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_fmod_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0)


	########################################################
	def test_nan_math_fmod_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_fmod_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0)


	########################################################
	def test_inf_math_fmod_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_fmod_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_fmod_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_fmod_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [100.0] * 10)
		self.dataok = array.array('d', [100.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_fmod_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_fmod_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_fmod_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_fmod_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_fmod_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_fmod_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_fmod_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_fmod_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_fmod_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_fmod_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_fmod_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.fmod(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# All error conditions expect NaN.
			expected = [float('nan')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_fmod_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_gamma_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_gamma_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.datanan, self.dataout)


	########################################################
	def test_nan_math_gamma_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datanan)


	########################################################
	def test_nan_math_gamma_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_gamma_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_gamma_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.datainf, self.dataout)


	########################################################
	def test_inf_math_gamma_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datainf)


	########################################################
	def test_inf_math_gamma_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_gamma_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_gamma_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_gamma, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_gamma_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_gamma, self.dataninf)


	########################################################
	def test_ninf_math_gamma_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_gamma, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_gamma_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_gamma, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan, -2.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf, -2.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  -1.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  -1.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  0.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  0.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  1.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  1.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_hypot_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  2.0)


	########################################################
	def test_nan_math_hypot_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_hypot_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  2.0)


	########################################################
	def test_inf_math_hypot_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_hypot_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_hypot_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  0.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_hypot_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_hypot_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_hypot_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_hypot_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_hypot_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_hypot_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_hypot_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_hypot_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_hypot_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_hypot_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_hypot_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_hypot_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.hypot(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_hypot_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_isinf_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_isinf_amap(self):
		"""Test amap for math_isinf with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datanan, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isinf_amapi(self):
		"""Test amapi for math_isinf with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datanan)

		self.assertEqual(list(self.datanan), expected)


	########################################################
	def test_nan_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datanan, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datanan, disovfl=True)

		self.assertEqual(list(self.datanan), expected)



	########################################################
	def test_inf_math_isinf_amap(self):
		"""Test amap for math_isinf with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datainf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isinf_amapi(self):
		"""Test amapi for math_isinf with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datainf)

		self.assertEqual(list(self.datainf), expected)


	########################################################
	def test_inf_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.datainf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.datainf, disovfl=True)

		self.assertEqual(list(self.datainf), expected)



	########################################################
	def test_ninf_math_isinf_amap(self):
		"""Test amap for math_isinf with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.dataninf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isinf_amapi(self):
		"""Test amapi for math_isinf with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.dataninf)

		self.assertEqual(list(self.dataninf), expected)


	########################################################
	def test_ninf_math_isinf_ov_amap(self):
		"""Test amap for math_isinf with overflow checking off with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isinf, self.dataninf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isinf_ov_amapi(self):
		"""Test amapi for math_isinf with overflow checking off with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isinf(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isinf, self.dataninf, disovfl=True)

		self.assertEqual(list(self.dataninf), expected)


##############################################################################

##############################################################################
class amap_nan_data_math_isnan_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_isnan_amap(self):
		"""Test amap for math_isnan with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datanan, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isnan_amapi(self):
		"""Test amapi for math_isnan with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datanan)

		self.assertEqual(list(self.datanan), expected)


	########################################################
	def test_nan_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datanan, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_nan_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with nan - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datanan, disovfl=True)

		self.assertEqual(list(self.datanan), expected)



	########################################################
	def test_inf_math_isnan_amap(self):
		"""Test amap for math_isnan with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datainf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isnan_amapi(self):
		"""Test amapi for math_isnan with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datainf)

		self.assertEqual(list(self.datainf), expected)


	########################################################
	def test_inf_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.datainf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_inf_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.datainf, disovfl=True)

		self.assertEqual(list(self.datainf), expected)



	########################################################
	def test_ninf_math_isnan_amap(self):
		"""Test amap for math_isnan with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.dataninf, self.dataout)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isnan_amapi(self):
		"""Test amapi for math_isnan with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.dataninf)

		self.assertEqual(list(self.dataninf), expected)


	########################################################
	def test_ninf_math_isnan_ov_amap(self):
		"""Test amap for math_isnan with overflow checking off with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_isnan, self.dataninf, self.dataout, disovfl=True)

		self.assertEqual(list(self.dataout), expected)


	########################################################
	def test_ninf_math_isnan_ov_amapi(self):
		"""Test amapi for math_isnan with overflow checking off with -inf - Array code d.
		"""
		# Calculate the expected result.
		expected = [float(math.isnan(x)) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_isnan, self.dataninf, disovfl=True)

		self.assertEqual(list(self.dataninf), expected)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan, -2.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf, -2.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok, -2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  -1.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  -1.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  -1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  0.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  0.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  0.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  1.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  1.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  1.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_ldexp_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_ldexp_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_ldexp_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  2.0)


	########################################################
	def test_nan_math_ldexp_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_ldexp_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_ldexp_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_ldexp_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  2.0)


	########################################################
	def test_inf_math_ldexp_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_ldexp_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataok, self.dataout,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_ldexp_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataok,  2.0)

		# This is the actual test.
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_ldexp_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_ldexp, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_ldexp_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.ldexp(x, int(y)) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_ldexp, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_lgamma_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_lgamma_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datanan, self.dataout)


	########################################################
	def test_nan_math_lgamma_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datanan)


	########################################################
	def test_nan_math_lgamma_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_lgamma_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_lgamma_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datainf, self.dataout)


	########################################################
	def test_inf_math_lgamma_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datainf)


	########################################################
	def test_inf_math_lgamma_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_lgamma_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_lgamma_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_lgamma, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_lgamma_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.dataninf)


	########################################################
	def test_ninf_math_lgamma_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_lgamma, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_lgamma_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.lgamma(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_lgamma, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_log_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.datanan)


	########################################################
	def test_nan_math_log_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.datainf)


	########################################################
	def test_inf_math_log_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log, self.dataninf)


	########################################################
	def test_ninf_math_log_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log10_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log10_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log10_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.datanan)


	########################################################
	def test_nan_math_log10_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log10_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log10_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log10_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.datainf)


	########################################################
	def test_inf_math_log10_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log10_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log10(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log10_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log10, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log10_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log10, self.dataninf)


	########################################################
	def test_ninf_math_log10_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log10, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log10_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log10, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log1p_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log1p_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log1p_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datanan)


	########################################################
	def test_nan_math_log1p_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log1p_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log1p_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log1p_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datainf)


	########################################################
	def test_inf_math_log1p_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log1p_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log1p(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log1p_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log1p, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log1p_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log1p, self.dataninf)


	########################################################
	def test_ninf_math_log1p_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log1p, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log1p_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log1p, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_log2_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [1.0] * 10)
		self.dataok = array.array('d', [1.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_log2_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.datanan, self.dataout)


	########################################################
	def test_nan_math_log2_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.datanan)


	########################################################
	def test_nan_math_log2_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_log2_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_log2_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.datainf, self.dataout)


	########################################################
	def test_inf_math_log2_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.datainf)


	########################################################
	def test_inf_math_log2_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_log2_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.log2(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_log2_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_log2, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_log2_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_log2, self.dataninf)


	########################################################
	def test_ninf_math_log2_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_log2, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_log2_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_log2, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok, 0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat(0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf, 0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_pow_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0)


	########################################################
	def test_nan_math_pow_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_pow_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0)


	########################################################
	def test_inf_math_pow_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_pow_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_pow_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(x, y) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok, -2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat(-2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf, -2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  -1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  0.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  1.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_pow_r_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_pow_r_amap(self):
		"""Test amap for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0)


	########################################################
	def test_nan_math_pow_r_amapi(self):
		"""Test amapi for data of nan where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0)


	########################################################
	def test_nan_math_pow_r_ov_amap(self):
		"""Test amap for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datanan, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_pow_r_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datanan), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datanan)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datanan,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_pow_r_amap(self):
		"""Test amap for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0)


	########################################################
	def test_inf_math_pow_r_amapi(self):
		"""Test amapi for data of inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0)


	########################################################
	def test_inf_math_pow_r_ov_amap(self):
		"""Test amap for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.datainf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.datainf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.datainf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.datainf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_pow_r_amap(self):
		"""Test amap for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataok, self.dataout,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0)
		else:
			arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0)


	########################################################
	def test_ninf_math_pow_r_amapi(self):
		"""Test amapi for data of -inf where an error is expected - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This version is expected to pass.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataok,  2.0)

		# This is the actual test. NaN, Inf, and -Inf are expected to raise errors.
		if not math.isfinite(expected[0]):
			with self.assertRaises(ArithmeticError):
				arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0)
		else:
			arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0)


	########################################################
	def test_ninf_math_pow_r_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_pow_r, self.dataninf, self.dataout,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_pow_r_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off - Array code d.
		"""
		# Calculate the expected result.
		try:
			expected = [math.pow(y, x) for x,y in zip(list(self.dataninf), itertools.repeat( 2.0))]
		except:
			# pow(0.0, -inf) is a special case.
			expected = [float('inf')] * len(self.dataninf)


		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_pow_r, self.dataninf,  2.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_radians_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_radians_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.datanan, self.dataout)


	########################################################
	def test_nan_math_radians_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.datanan)


	########################################################
	def test_nan_math_radians_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_radians_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_radians_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.datainf, self.dataout)


	########################################################
	def test_inf_math_radians_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.datainf)


	########################################################
	def test_inf_math_radians_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_radians_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_radians_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_radians, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_radians_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_radians, self.dataninf)


	########################################################
	def test_ninf_math_radians_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_radians, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_radians_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.radians(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_radians, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_sin_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sin_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sin_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.datanan)


	########################################################
	def test_nan_math_sin_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sin_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sin(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sin_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sin_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.datainf)


	########################################################
	def test_inf_math_sin_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_sin_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_sin_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sin, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sin_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sin, self.dataninf)


	########################################################
	def test_ninf_math_sin_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sin, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_sin_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sin, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_sinh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sinh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sinh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datanan)


	########################################################
	def test_nan_math_sinh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sinh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sinh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sinh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datainf)


	########################################################
	def test_inf_math_sinh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_sinh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sinh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sinh, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sinh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sinh, self.dataninf)


	########################################################
	def test_ninf_math_sinh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sinh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_sinh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sinh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sinh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_sqrt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_sqrt_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datanan, self.dataout)


	########################################################
	def test_nan_math_sqrt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datanan)


	########################################################
	def test_nan_math_sqrt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_sqrt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_sqrt_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datainf, self.dataout)


	########################################################
	def test_inf_math_sqrt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datainf)


	########################################################
	def test_inf_math_sqrt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_sqrt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.sqrt(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_sqrt_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_sqrt, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_sqrt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.dataninf)


	########################################################
	def test_ninf_math_sqrt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_sqrt, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_sqrt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_sqrt, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_tan_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tan_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.datanan, self.dataout)


	########################################################
	def test_nan_math_tan_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.datanan)


	########################################################
	def test_nan_math_tan_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_tan_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tan(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tan_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.datainf, self.dataout)


	########################################################
	def test_inf_math_tan_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.datainf)


	########################################################
	def test_inf_math_tan_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_tan_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_tan_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tan, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_tan_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tan, self.dataninf)


	########################################################
	def test_ninf_math_tan_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tan, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_tan_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tan, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_math_tanh_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_tanh_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_tanh, self.datanan, self.dataout)


	########################################################
	def test_nan_math_tanh_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datanan)


	########################################################
	def test_nan_math_tanh_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datanan, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_math_tanh_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datanan]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datanan, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_math_tanh_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datainf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datainf)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.datainf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_math_tanh_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.datainf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.datainf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_math_tanh_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.dataninf, self.dataout)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.dataninf)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_tanh, self.dataninf, self.dataout, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_math_tanh_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# Calculate the expected result.
		expected = [math.tanh(x) for x in self.dataninf]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_tanh, self.dataninf, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_math_trunc_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [0.0] * 10)
		self.dataok = array.array('d', [0.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_math_trunc_amap(self):
		"""Test amap for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.datanan, self.dataout)


	########################################################
	def test_nan_math_trunc_amapi(self):
		"""Test amapi for data of nan with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datanan)


	########################################################
	def test_nan_math_trunc_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.datanan, self.dataout, disovfl=True)


	########################################################
	def test_nan_math_trunc_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datanan, disovfl=True)



	########################################################
	def test_inf_math_trunc_amap(self):
		"""Test amap for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.datainf, self.dataout)


	########################################################
	def test_inf_math_trunc_amapi(self):
		"""Test amapi for data of inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datainf)


	########################################################
	def test_inf_math_trunc_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.datainf, self.dataout, disovfl=True)


	########################################################
	def test_inf_math_trunc_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.datainf, disovfl=True)



	########################################################
	def test_ninf_math_trunc_amap(self):
		"""Test amap for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amap(arrayfunc.aops.math_trunc, self.dataninf, self.dataout)


	########################################################
	def test_ninf_math_trunc_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and single parameter functions  - Array code d.
		"""
		with self.assertRaises(ArithmeticError):
			arrayfunc.amapi(arrayfunc.aops.math_trunc, self.dataninf)


	########################################################
	def test_ninf_math_trunc_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.math_trunc, self.dataninf, self.dataout, disovfl=True)


	########################################################
	def test_ninf_math_trunc_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and single parameter functions  - Array code d.
		"""
		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.math_trunc, self.dataninf, disovfl=True)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gt_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x > y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_gte_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_gte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_gte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_gte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_gte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_gte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x >= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_gte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lt_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lt_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lt_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lt_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lt, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lt_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x < y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lt, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_0_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf, -5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of -5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat(-5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf, -5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_1_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  -1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  -1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( -1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  -1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_2_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  0.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  0.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 0.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  0.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_3_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  1.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  1.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 1.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  1.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
class amap_nan_data_aops_subst_lte_4_d(unittest.TestCase):
	"""Test floating point arrays for nan, inf, -inf in data.
	"""

	########################################################
	def setUp(self):
		"""Initialise.
		"""
		self.data = array.array('d', [-5.0] * 10)
		self.dataok = array.array('d', [-5.0] * 10)

		self.dataout = array.array('d', itertools.repeat(0.0, 10))

		self.datainf = array.array('d', [float('inf')] * 10)
		self.datanan = array.array('d', [float('nan')] * 10)
		self.dataninf = array.array('d', [float('-inf')] * 10)


	########################################################
	def test_nan_aops_subst_lte_amap(self):
		"""Test amap for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_amapi(self):
		"""Test amapi for data of nan with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amap(self):
		"""Test amap for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datanan, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_nan_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of nan with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datanan), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datanan,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datanan), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_inf_aops_subst_lte_amap(self):
		"""Test amap for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_amapi(self):
		"""Test amapi for data of inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.datainf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_inf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.datainf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.datainf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.datainf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)



	########################################################
	def test_ninf_aops_subst_lte_amap(self):
		"""Test amap for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_amapi(self):
		"""Test amapi for data of -inf with overflow checking on and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  5.0)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amap(self):
		"""Test amap for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amap(arrayfunc.aops.aops_subst_lte, self.dataninf, self.dataout,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataout), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


	########################################################
	def test_ninf_aops_subst_lte_ov_amapi(self):
		"""Test amapi for data of -inf with overflow checking off and param data of  5.0  - Array code d.
		"""
		# Calculate the expected result.
		expected = [y if x <= y else x for x,y in zip(list(self.dataninf), itertools.repeat( 5.0))]

		# This is the actual test.
		arrayfunc.amapi(arrayfunc.aops.aops_subst_lte, self.dataninf,  5.0, disovfl=True)

		for dataoutitem, expecteditem in zip(list(self.dataninf), expected):
			# NaN cannot be compared using normal means.
			if math.isnan(expecteditem):
				self.assertTrue(math.isnan(dataoutitem))
			elif math.isnan(dataoutitem):
				self.assertTrue(math.isnan(expecteditem))
			# Inf or -inf can be compared using an exact match.
			elif (not math.isfinite(dataoutitem)) or (not math.isfinite(expecteditem)):
				self.assertEqual(dataoutitem, expecteditem)
			# Anything else can be compared normally.
			else:
				deltaval = min((abs(expecteditem), abs(dataoutitem))) / 100.0
				self.assertAlmostEqual(dataoutitem, expecteditem, delta=deltaval)


##############################################################################

##############################################################################
if __name__ == '__main__':

	# Check to see if the log file option has been selected. This is an option
	# which we have added in order to decide where to output the results.
	if '-l' in sys.argv:
		# Remove the option from the argument list so that "unittest" does 
		# not complain about unknown options.
		sys.argv.remove('-l')

		with open('arrayfunc_unittest.txt', 'a') as f:
			f.write('

')
			f.write('amap

')
			trun = unittest.TextTestRunner(f)
			unittest.main(testRunner=trun)
	else:
		unittest.main()

##############################################################################
